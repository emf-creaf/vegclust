[{"path":"https://emf-creaf.github.io/vegclust/articles/MedRegExample.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Describing vegetation in terms of structure and composition","text":"aim tutorial show implement method calculate dissimilarities communities presented De Caceres et al (2013). method allows incorporating structure composition community dissimilary measurement. functions needed carry computations included package vegclust start loading package:","code":"library(vegclust)"},{"path":"https://emf-creaf.github.io/vegclust/articles/MedRegExample.html","id":"post-fire-vegetation-regeneration-data","dir":"Articles","previous_headings":"","what":"Post-fire vegetation regeneration data","title":"Describing vegetation in terms of structure and composition","text":"order illustrate method use stratified vegetation data set containing data 96 stands. data obtained investigate patterns vegetation regeneration three years impact wildfire. Data collected 2012 Miquel De Caceres Albert Petit Horta de Sant Joan (Catalonia, Spain). R object class stratifiedvegdata (actually list). dataset contains 96 stands (list elements), data.frame rows correspond broad plant functional groups (Pine trees, Oak trees, Tall shrubs small trees, Scrubs small shrubs Grass) columns correspond vegetation strata (1 7). upper heights vegetation strata following (cm.) vector: width (range heights) stratum : Species abundance values percentage cover values estimated using cover classes: data read follows. Shrubs reaching stratum 3 (50 - 100 cm) cumulative cover 25%, shrubs reaching stratum 2 (20 - 50 cm) cumulative cover 62.5%. Thus, observers grouped plants according height functional group, estimated cover groups plants.","code":"data(medreg) class(medreg) ## [1] \"stratifiedvegdata\" \"list\" length(medreg) ## [1] 96 strataUp = c(20,50,100,300,600,1200,2400) strataWidths = c(20,30,50,200,300,600,1200) medreg[[1]] ##                                1    2  3 4 5 6 7 ## Pine trees                   0.0  0.0  0 0 0 0 0 ## Quercus trees               12.5 25.0  0 0 0 0 0 ## Tall shrubs and small trees  0.0 62.5 25 0 0 0 0 ## Scrubs and small shrubs     12.5 37.5  0 0 0 0 0 ## Grass                       50.0  0.0  0 0 0 0 0"},{"path":"https://emf-creaf.github.io/vegclust/articles/MedRegExample.html","id":"cumulative-abundance-profiles","dir":"Articles","previous_headings":"","what":"Cumulative abundance profiles","title":"Describing vegetation in terms of structure and composition","text":"cumulative abundance profile (CAP) function takes value size input (size vegetation stratum) returns cumulative abundance organisms (cumulative cover value) whose size equal larger input value. case, CAP function cumulative cover plants reaching current stratum higher strata. Calculations made using function CAP() vegclust: Note different CAP calculated functional group plot. structure resulting R object similar stratified data: inspect first element list, can see difference original data cumulative abundance profile. Moreover, possible graphically display CAP given stand (may become difficult interpret number species large). example, can display CAP functional group first stand (plots=\"1\"):  case vegetation short dense shrubland. Note plot used strataUp set x-axis, real heights adequately represented.","code":"medreg.CAP <- CAP(medreg) class(medreg.CAP) ## [1] \"CAP\"  \"list\" length(medreg.CAP) ## [1] 96 medreg.CAP[[1]] ##                                1    2  3 4 5 6 7 ## Pine trees                   0.0  0.0  0 0 0 0 0 ## Quercus trees               37.5 25.0  0 0 0 0 0 ## Tall shrubs and small trees 87.5 87.5 25 0 0 0 0 ## Scrubs and small shrubs     50.0 37.5  0 0 0 0 0 ## Grass                       50.0  0.0  0 0 0 0 0 plot(medreg.CAP, plots=\"1\", sizes=strataUp, xlab=\"Height (cm)\",       ylab=\"Cumulative percent cover\") legend(\"topright\", col=1:5, lty=1,         legend=c(\"Pines\",\"Oaks\",\"Tall shrubs\",\"Scrubs\",\"Grass\"),         bty=\"n\")"},{"path":"https://emf-creaf.github.io/vegclust/articles/MedRegExample.html","id":"cumulative-abundance-surfaces","dir":"Articles","previous_headings":"","what":"Cumulative abundance surfaces","title":"Describing vegetation in terms of structure and composition","text":"concept cumulative abundance profile can extended two structural variables, leads concept cumulative abundance surface (CAS). CAS function takes values two structural variables (size1 size2) input returns cumulative abundance organisms whose size equal larger input values one structural variables . case forests, natural choices structural variables tree diameter tree height. Since post-fire regeneration dataset includes one structural variable, illustrate concept CASs using synthetic data set consisting single plot species identity, diameter height hundred trees measured. start building tree-based data set: example, use basal area (m2) measure abundance. calculate area (square meters) tree: specific data looks follows: start analysis defining two sets size classes, one height diameter: ready stratify data set: Function stratifyvegdata() used reshape data sets suitable calculating CAPs CASs. case one structural variable, function returns list matrices, one plot. post-fire vegetation data presented previous section example . case two structural variables, stratifyvegdata() returns list three-dimensional arrays, one plot. cumulative abundance surface calculated using function CAS: can plot surface corresponding species follows:  One nice property CAS marginal distributions CAPs. can easily shown compare marginal CAP height: CAP directly build using heights: Finally, compare previous three-dimensional figures, marginal CAP plots diameters heights:","code":"pl = rep(1,100) # All trees in the same plot sp = ifelse(runif(100)>0.5,1,2) # Random species identity (species 1 or 2) h = pmin(100,rgamma(100,10,2)) # Heights (m) d = pmin(150,rpois(100, lambda=h^2)) # Diameters (cm) m = data.frame(plot=pl,species=sp, height=h,diameter=d) m$ba = pi*(m$diameter/200)^2 print(head(m)) ##   plot species   height diameter         ba ## 1    1       2 6.171464       36 0.10178760 ## 2    1       1 4.382543       22 0.03801327 ## 3    1       1 5.446999       23 0.04154756 ## 4    1       2 5.408527       27 0.05725553 ## 5    1       2 6.373799       42 0.13854424 ## 6    1       2 6.681184       45 0.15904313 heights = seq(0,5, by=.25)^2 # Quadratic classes diams = seq(0,150, by=5) # Linear classes tree.S<-stratifyvegdata(m, sizes1=heights, sizes2=diams,                     plotColumn = \"plot\", speciesColumn = \"species\",                     size1Column = \"height\", size2Column = \"diameter\",                     abundanceColumn = \"ba\") tree.CAS <- CAS(tree.S) par(mfrow=c(2,1), mar=c(4,5,2,1)) plot(tree.CAS, species=1, sizes1=heights[-1], xlab=\"height (m)\",       ylab=\"diameter (cm)\", sizes2=diams[-1], zlab=\"Basal area (m2)\",      zlim = c(0,6), main=\"Species 1\") plot(tree.CAS, species=2, sizes1=heights[-1], xlab=\"height (m)\",       ylab=\"diameter (cm)\", sizes2=diams[-1], zlab=\"Basal area (m2)\",      zlim = c(0,6), main = \"Species 2\") print(CASmargin(tree.CAS, margin=1)) ## $`1` ##   [0,0.0625] (0.0625,0.25] (0.25,0.562] (0.562,1] (1,1.56] (1.56,2.25] ## 1   4.055089      4.055089     4.055089  4.055089 4.055089    4.055089 ## 2   4.708148      4.708148     4.708148  4.708148 4.708148    4.708148 ##   (2.25,3.06] (3.06,4] (4,5.06] (5.06,6.25] (6.25,7.56]  (7.56,9] (9,10.6] ## 1    4.054068 4.050691 3.989351    3.648646    2.704440 0.5469513        0 ## 2    4.708148 4.693539 4.520830    4.088861    2.684177 1.0380608        0 ##   (10.6,12.2] (12.2,14.1] (14.1,16] (16,18.1] (18.1,20.2] (20.2,22.6] (22.6,25] ## 1           0           0         0         0           0           0         0 ## 2           0           0         0         0           0           0         0 ##  ## attr(,\"class\") ## [1] \"CAP\"  \"list\" tree.S2<-stratifyvegdata(m, sizes1=heights, plotColumn = \"plot\",                           speciesColumn = \"species\", size1Column = \"height\",                           abundanceColumn = \"ba\") print(CAP(tree.S2)) ## $`1` ##   [0,0.0625] (0.0625,0.25] (0.25,0.562] (0.562,1] (1,1.56] (1.56,2.25] ## 1   4.055089      4.055089     4.055089  4.055089 4.055089    4.055089 ## 2   4.708148      4.708148     4.708148  4.708148 4.708148    4.708148 ##   (2.25,3.06] (3.06,4] (4,5.06] (5.06,6.25] (6.25,7.56]  (7.56,9] (9,10.6] ## 1    4.054068 4.050691 3.989351    3.648646    2.704440 0.5469513        0 ## 2    4.708148 4.693539 4.520830    4.088861    2.684177 1.0380608        0 ##   (10.6,12.2] (12.2,14.1] (14.1,16] (16,18.1] (18.1,20.2] (20.2,22.6] (22.6,25] ## 1           0           0         0         0           0           0         0 ## 2           0           0         0         0           0           0         0 ##  ## attr(,\"class\") ## [1] \"CAP\"  \"list\" par(mfrow=c(2,1), mar=c(4,5,2,1)) plot(CASmargin(tree.CAS,margin=1), plots=1, sizes=heights[-1],       xlab=\"height (m)\", ylab=\"Basal area (m2)\", ylim = c(0,7)) plot(CASmargin(tree.CAS,margin=2), plots=1, sizes=diams[-1],       xlab=\"diameter (cm)\", ylab=\"Basal area (m2)\", ylim = c(0,7))"},{"path":"https://emf-creaf.github.io/vegclust/articles/MedRegExample.html","id":"dissimilarities-in-structure-and-composition","dir":"Articles","previous_headings":"","what":"Dissimilarities in structure and composition","title":"Describing vegetation in terms of structure and composition","text":"Although CAPs can used graphically display structure composition vegetation stands, whole point defining CAP function allow comparisons stands. Returning post-fire vegetation regeneration data, can calculate dissimilarities pairs stands, thus obtaining square symmetric matrix dissimilarity values: sentence forced strata different weight, according range heights stratum occupies. different alternatives respect dissimilarity index. case chose CAP generalization Bray-Curtis (De Caceres et al 2013). want know, example, dissimilarity stands 1' and2’ simply write: calculating dissimilarities possible transform CAP values order prevent large abundance values undue influence analysis. case choose take square root cumulative cover values: can use metric multidimensional scaling represent distances stands obtained cases:  Note differences two ordination plots remarkable.","code":"medreg.D = vegdiststruct(medreg.CAP, method=\"bray\",                           classWeights=strataWidths) as.matrix(medreg.D)[1,2] ## [1] 0.2713178 medreg.Dsqrt = vegdiststruct(medreg.CAP, method=\"bray\",                           classWeights=strataWidths, transform=\"sqrt\") par(mfrow=c(2,1), mar=c(4,5,2,1)) X<-cmdscale(medreg.D, k=2) plot(X, xlab=\"MDS 1\", ylab=\"MDS 2\", asp=1,      main=\"Cover untransformed\", cex=0.5) Xsqrt<-cmdscale(medreg.Dsqrt, k=2) plot(Xsqrt, xlab=\"MDS 1\", ylab=\"MDS 2\", asp=1,      main=\"Cover sqrt-transformed\", cex=0.5)"},{"path":"https://emf-creaf.github.io/vegclust/articles/MedRegExample.html","id":"classification-of-vegetation-stands","dir":"Articles","previous_headings":"","what":"Classification of vegetation stands","title":"Describing vegetation in terms of structure and composition","text":"section use square-root transformed dissimilarities vegetation stands obtain classification stands terms structure composition. familiarized non-hierarchical clustering, can read tutorial vegclust package. start setting number clusters found (nclusters) size clusters (dnoise, parameter used leave stands far group prototypes unclassified): call function vegclust() using clustering method \"HNCdd\", indicates () hard clustering, (b) medoids prototypes, (c) noise clustering (.e. excluding outliers special class called noise class): nstart=100 indicate algorithm run 100 times starting random seeds. advisable order maximize chance suboptimal solutions. prototypes identified algorithm following medoids (indices stands medreg): number stands belonging cluster can found using: Note , model chosen (parameter dnoise), number stands left unclassified (.e. assigned class “N”). useful way display results cluster analysis showing stand memberships clusters ordination:  stands belonging true clusters less close, assigned noise can far appart, fact makes class lack membership true clusters. facilitate interpretation clusters can extract cumulative abundance profiles cluster medoids: example, can inspect structure composition fourth group: following displays graphically CAPs six groups vegetation stands (code shown):","code":"nclusters = 6 dnoise = 0.40 vc<-vegclustdist(medreg.Dsqrt, mobileMemb = nclusters,                   method=\"HNCdd\", dnoise=dnoise, nstart=100) medoids<-vc$mobileCenters print(medoids) ## [1] 60 24 71 20 92 38 cluster<-defuzzify(vc)$cluster table(cluster) ## cluster ## M1 M2 M3 M4 M5 M6  N  ##  8 28 15 21  9  7  8 clNum = as.numeric(as.factor(cluster)) plot(Xsqrt, xlab=\"MDS 1\", ylab=\"MDS 2\",       pch=clNum, col=clNum) legend(\"topleft\", col=1:(nclusters+1), pch=1:(nclusters+1),        legend=levels(as.factor(cluster)), bty=\"n\") CAPm = CAPcenters(medreg.CAP, vc) n = names(CAPm) round(CAPm[[n[4]]], dig=1) ##                                1    2 3 4 5 6 7 ## Pine trees                   0.0  0.0 0 0 0 0 0 ## Quercus trees               12.5 12.5 0 0 0 0 0 ## Tall shrubs and small trees 37.5 37.5 0 0 0 0 0 ## Scrubs and small shrubs     30.0 30.0 0 0 0 0 0 ## Grass                       62.5  0.0 0 0 0 0 0"},{"path":"https://emf-creaf.github.io/vegclust/articles/MedRegExample.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Describing vegetation in terms of structure and composition","text":"De Cáceres, M., Legendre, P., & , F. 2013. Dissimilarity measurements size structure ecological communities (D. Faith, Ed.). Methods Ecology Evolution 4: 1167–1177.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"what-is-this-tutorial-about","dir":"Articles","previous_headings":"Introduction","what":"What is this tutorial about?","title":"How to use the vegclust package","text":"Classification vegetation plot records involves different activities, including design appropriate vegetation survey, use classification method group vegetation observations characterization, validation naming resulting vegetation groups. tutorial focus one steps, namely group vegetation observations, show conduct help R package vegclust. starting examples need load vegclust package package vegan:","code":"library(vegclust) library(vegan) #> Loading required package: permute #> Loading required package: lattice"},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"example-vegetation-data","dir":"Articles","previous_headings":"Introduction","what":"Example vegetation data","title":"How to use the vegclust package","text":"order illustrate functions vegclust use small wetland vegetation data set, consisting 41 sites 33 species published Bowman Wilson (1986). data included vegclust package: number reasons detail , Euclidean distance appropriate index measure resemblance species composition vegetation plot records. Therefore, transform community data using chord transformation (Legendre Gallagher 2001), divides value norm row vector corresponding site: Function decostand() provided within vegan package. Euclidean distance transformed data equal chord distance (Orlóci 1967) respect raw community data: examples use R objects wetlandchord dchord indistinctively, package vegclust allows vegetation classified either site--species data table site--site dissimilarity matrix. next section briefly explain bases classification methods provided vegclust package. later show run methods using functions package.","code":"data(wetland) dim(wetland) #> [1] 41 33 wetlandchord = decostand(wetland,\"normalize\") dchord = dist(wetlandchord)"},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"resemblance-space","dir":"Articles","previous_headings":"Clustering methods in vegclust","what":"Resemblance space","title":"How to use the vegclust package","text":"Generally speaking, goal clustering derive cc ‘natural’ classes clusters set nn unlabelled objects. objects inside `natural’ cluster show certain degree closeness similarity cluster shows certain degree isolation clusters. classification vegetation nn ‘objects’ grouped samples plant communities (.e. plot records relevés) goal define vegetation types. speaking ‘proximity’ ‘similarity’, implicitly assume procedure assess degree resemblance objects grouped. procedure usually involves describing objects using set pp features (normally species case vegetation) specifying resemblance measure (e.g. distance dissimilarity). Let 𝐗=[xjs]\\mathbf{X}=[x_{js}] site--species data table dimensions n×pn\\times p, xjsx_{js} abundance species ss site jj, let dd appropriate dissimilarity distance measure. Another way formalize resemblance objects directly provide similarity dissimilarity pairs objects symmetric resemblance matrix. Let 𝐃=[dij]\\mathbf{D}=[d_{ij}] symmetric dissimilarity matrix dimensions n×nn\\times n, dij=d(𝐱i,𝐱j)d_{ij} = d(\\mathbf{x}_i,\\mathbf{x}_j) dissimilarity objects ii jj. classification vegetation dij=d(𝐱i,𝐱j)d_{ij} = d(\\mathbf{x}_i,\\mathbf{x}_j) may represent compositional dissimilarity two plant communities ii jj, based vegetation attributes physiognomy. Regardless whether use 𝐗\\mathbf{X} 𝐃\\mathbf{D}, speak resemblance space objects (plant communities) formally represented points space. Although cover topic detail , reader aware building appropriate resemblance space critical achieving vegetation classification fits given purpose. results classification exercise may completely different depending way resemblance space defined.","code":""},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"prototype-based-clustering","dir":"Articles","previous_headings":"Clustering methods in vegclust","what":"Prototype-based clustering","title":"How to use the vegclust package","text":"Prototype-based clustering methods assume properties objects cluster can represented using cluster prototype, formalized point resemblance space. problem thus find cc prototypes assign nn objects according proximity prototypes, resulting clusters compact isolated one another. clustering methods discussed follow alternate optimization scheme, meaning one group parameters (e.g. membership matrix) optimized holding group (e.g. cluster prototypes) fixed vice versa. Assuming initial cluster configuration, achieved iterating following three steps: Determine prototype cluster ii. Calculate eije_{ij}, distance object jj prototype cluster ii. Calculate uiju_{ij}, (hard fuzzy) membership object jj cluster ii (.e. re-assign objects clusters). iteration alternate optimization algorithm improves objective function clustering method. alternate optimization algorithm stops changes object memberships. technically, stops maximum difference object membership values last two iterations exceed user-specified threshold. starting configuration clusters critical issue kind classification methods, iterations can result alternate optimization algorithm getting stuck suboptimal value objective function. reason, several executions algorithm usually tried, one using different starting configuration.","code":""},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"clustering-models","dir":"Articles","previous_headings":"Clustering methods in vegclust","what":"Clustering models","title":"How to use the vegclust package","text":"several prototype-based clustering models vegclust package; follow iterative algorithm presented . differences clustering models arise due differences specific implementation step, resulting different assumptions clusters defined. clustering models can divided according properties : Whether object memberships fuzzy hard (crisp). Whether cluster prototypes centroids medoids. outlier objects handled, gives three kinds models: partitive, noise clustering possibilistic clustering. following subsections describe implications decisions.","code":""},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"hard-crisp-or-fuzzy-memberships","dir":"Articles","previous_headings":"Clustering methods in vegclust > Clustering models","what":"Hard (crisp) or fuzzy memberships","title":"How to use the vegclust package","text":"kind classification methods described , costumary represent classification objects groups using c×nc\\times n membership matrix, 𝐔=[uij]\\mathbf{U}=[u_{ij}], uiju_{ij} degree membership object jj cluster ii. classification said hard uiju_{ij} values either 0 (object jj belong cluster ii) 1 (object jj belong cluster ii). contrast, classification fuzzy membership objects expressed degree membership bounded 0 (.e. object belong set ) 1 (.e. object belongs completely set). advantages using fuzzy set theory vegetation classification acknowledges individualistic concept species distribution across gradients vegetation composition (Moravec 1989), therefore avoids assuming vegetation observations (e.g. releves) must unequivocal representatives type without admixture types (Dale 1995).","code":""},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"centroids-or-medoids","dir":"Articles","previous_headings":"Clustering methods in vegclust > Clustering models","what":"Centroids or medoids","title":"How to use the vegclust package","text":"centroid cluster ii contains nin_i objects vector 𝐜i\\mathbf{c}_i whose coordinates average, dimension ss, coordinates nin_i objects belonging cluster. vector notation: 𝐜i=∑j=1ni𝐱jni\\begin{equation}\\label{eq:centroid} \\mathbf{c}_{} = \\frac{\\sum_{j=1}^{n_i}{\\mathbf{x}_{j}}}{n_i} \\end{equation} centroid property minimizes sum squared Euclidean distances point belonging cluster. Equation~ can generalized case fuzzy cluster weighting coordinates object degree membership cluster, uiju_{ij}: 𝐜i=∑j=1nuijm𝐱j∑j=1nuijm\\begin{equation} \\mathbf{c}_{} = \\frac{\\sum_{j=1}^n{u_{ij}^m\\mathbf{x}_{j}}}{\\sum_{j=1}^n{u_{ij}^m}}  \\end{equation} former equation, m>0m > 0 fuzziness exponent, used modulate influence fuzzy memberships calculation centroids. mm large objects whose membership close 1 influence centroid. contrary, mm small (.e. close 0) nn objects influence centroid equally approach overall data center. medoid cluster ii contains nin_i objects defined object, chosen among nin_i objects, sum dissimilarities nin_i objects minimal .e. centrally located point cluster. Formally, medoid object kk : ∑j=1nid(𝐱k,𝐱j)\\begin{equation} \\sum_{j=1}^{n_i}{d(\\mathbf{x}_k,\\mathbf{x}_j)} \\end{equation} minimal. using fuzzy logic, medoid cluster ii defined object kk (among nn objects) minimizes: ∑j=1nuijmd(𝐱k,𝐱j)\\begin{equation} \\sum_{j=1}^n{u_{ij}^md(\\mathbf{x}_k,\\mathbf{x}_j)} \\end{equation} Note , medoid point chosen among nn input objects, need calculate coordinates (although see explanation centroids), moreover, distance medoid objects (step #2 alternate optimization algorithm) readily available beginning, need computed. makes dealing medoids computationally much faster dealing centroids.","code":""},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"partitive-clustering","dir":"Articles","previous_headings":"Clustering methods in vegclust > Clustering models","what":"Partitive clustering","title":"How to use the vegclust package","text":"clustering method called partitive object memberships (crisp fuzzy) constrained sum one object: ∑=1cuij=1\\begin{equation}\\label{eq:partition} \\sum_{=1}^c{u_{ij}}=1 \\end{equation} constrain usually referred partition restriction. ensures objects classified either belonging single cluster dividing membership among different clusters. objects left unclassified. K-means (KM, also known hard c-means) (MacQueen 1967) Fuzzy c-means (FCM) (Bezdek 1981) two, centroid-based, partitive clustering algorithms widely used many unsupervised pattern recognition applications. main difference two methods KM every object belongs single cluster (.e clusters `hard’) whereas FCM memberships fuzzy given object may degree membership one cluster. Cluster memberships (step #3) determined KM simply assigning object cluster whose centroid closest. case FCM, fuzzy memberships calculated using following formula: uij=1∑l=1c(eij/elj)2/(m−1)\\begin{equation} u_{ij} = \\frac{1}{\\sum_{l=1}^c{(e_{ij}/e_{lj})^{2/(m-1)}}} \\end{equation} said , m>1m>1 fuzziness coefficient. smaller value mm, closer hard partition result. mm set high data noisy resulting partition may completely fuzzy (.e. uij=1/cu_{ij}=1/c objects clusters) therefore uninformative. indicated , KM FCM centroid-based, meaning use centroid-based crisp fuzzy equations, respectively, step #1. corresponding medoid-based methods Hard C-medoids Fuzzy C-medoids, instead use equations medoid-based crisp fuzzy equations, respectively (Raghu Krishnapuram, Joshi, Yi 1999).","code":""},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"noise-clustering","dir":"Articles","previous_headings":"Clustering methods in vegclust > Clustering models","what":"Noise clustering","title":"How to use the vegclust package","text":"noise clustering (NC) method (R. N. Dave 1991) attempt make FCM method robust effect outliers. rationale underlying NC following: object outlier, means lies far cluster prototypes , therefore, low membership values clusters. order achieve low memberships, NC considers additional class, called Noise. class represented ‘prototype’, like cc ‘true’ clusters. effect including Noise class ‘captures’ objects distances larger δ\\delta cc ‘true’ prototypes. NC membership function (step #3) ‘real’ clusters : uij=1(eij/δ)2/(m−1)+∑l=1c(eij/elj)2/(m−1)\\begin{equation} u_{ij} = \\frac{1}{(e_{ij}/\\delta)^{2/(m-1)}+\\sum_{l=1}^c{(e_{ij}/e_{lj})^{2/(m-1)}}} \\end{equation} whereas fuzzy membership Noise class, uNju_{Nj}, one minus sum memberships real clusters. uNj=1−∑=1cuij\\begin{equation} u_{Nj} = 1 - \\sum_{=1}^c{u_{ij}} \\end{equation} Outlier objects small membership values cc real clusters first term denominator noise membership equation large. smaller δ\\delta, higher memberships Noise class . contrast, large values δ\\delta make NC equivalent FCM. NC, fuzziness exponent mm interpretation FCM. Including Noise class effect relaxing partition restriction. NC, partition restriction fulfilled cc real clusters Noise class considered. Note , like FCM KM, can define ‘hard’ counterpart (fuzzy) noise clustering method. Indeed, hard noise clustering (HNC) method differs fuzzy one memberships fuzzy. Like KM, membership function can described verbally. One assigns object noise class distances cluster centroids larger δ\\delta. Otherwise, one assigns object cluster whose centroid closest, KM. noise clustering method originally defined centroids prototypes. However, either hard fuzzy noise clustering can applied medoids instead centroids. Although found references exploring approach, corresponding algorithms named ‘hard noise clustering medoids’ (HNCdd) ‘(fuzzy) noise clustering medoids’ (NCdd).","code":""},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"possibilistic-clustering","dir":"Articles","previous_headings":"Clustering methods in vegclust > Clustering models","what":"Possibilistic clustering","title":"How to use the vegclust package","text":"Possibilistic C-means (R. Krishnapuram Keller 1993, 1996) another modification FCM seeking increased cluster robustness. partition restriction eliminated PCM, produces cc independent fuzzy clusters, corresponding dense region points. Whereas FCM NC membership functions compare distance object cluster interest, eije_{ij}, distances remaining prototypes (noise class case NC), PCM membership value given object cluster depend distances remaining cluster prototypes. Instead, distance cluster interest compared reference distance (ηi\\eta_i): uij=11+(eij2/ηi)1/(m−1)\\begin{equation} u_{ij} = \\frac{1}{1+(e^2_{ij}/\\eta_i)^{1/(m-1)}} \\end{equation} reference distance parameter must provided cluster. objects whose distance cluster center smaller ηi\\eta_i obtain membership value higher 0.5. fact membership given cluster depend distances remaining cluster prototypes entails cluster repulsion eliminated PCM, consequence samples can high membership different clusters. Good estimation ηi\\eta_i crucial success PCM method (De Cáceres, Oliva, Font 2006). Inadequate initialization ηi\\eta_i can lead loss cluster structures, even correct partition initial starting configuration. single PCM run can regarded cc independent runs NC, looking single cluster δi2=ηi\\delta_i^2=\\eta_i(R. N. Dave Krishnapuram 1997). vegetation data plant communities intermediate characteristics frequent. fact makes PCM method impractical classification vegetation, without cluster repulsion PCM clusters frequently highly mobile converge cluster, leaving large parts data unassigned (De Cáceres, Font, Oliva 2010).","code":""},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"dissimilarity-based-duals","dir":"Articles","previous_headings":"Clustering methods in vegclust","what":"Dissimilarity-based duals","title":"How to use the vegclust package","text":"clustering methods presented can executed resemblance space described using either 𝐗\\mathbf{X} 𝐃\\mathbf{D}. latter case avoids explicitly dealing coordinates creating groups.","code":""},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"medoid-based-clustering-and-dissimilarity-matrices","dir":"Articles","previous_headings":"Clustering methods in vegclust > Dissimilarity-based duals","what":"Medoid-based clustering and dissimilarity matrices","title":"How to use the vegclust package","text":"medoids selected among objects classified obvious distance cluster prototypes, eije_{ij}, can drawn symmetric matrix pairwise distances objects calculated alternate optimization algorithm initiated. words, one can conduct medoid-based clustering site--site distance matrix instead using site--species rectangular matrix. Moreover, one can straightforwardly skip use Euclidean distance use dissimilarity measure appropriate ecological data.","code":""},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"centroid-based-clustering-and-dissimilarity-matrices","dir":"Articles","previous_headings":"Clustering methods in vegclust > Dissimilarity-based duals","what":"Centroid-based clustering and dissimilarity matrices","title":"How to use the vegclust package","text":"dealing centroids, may seem unavoidable calculate centroid coordinates (step S.1) calculating (squared) Euclidean distances cluster centers eije_{ij} (step S.2): eij2=∥𝐜i−𝐱j∥2\\begin{equation} e_{ij}^2 = \\| \\mathbf{c}_i-\\mathbf{x}_j \\|^2 \\end{equation} However, mathematical trick avoids need calculate coordinates 𝐜i\\mathbf{c}_i explictly. Let 𝐃\\mathbf{D} matrix Euclidean distances pairs objects. can obtain eij2e_{ij}^2 follows: eij2=1ni∑l=1nidlj2−12ni2∑k=1ni∑l=1nidlk2\\begin{equation} e_{ij}^2 = \\frac{1}{n_i}\\sum_{l=1}^{n_i}{d_{lj}^2}- \\frac{1}{2n_i^2}\\sum_{k=1}^{n_i}\\sum_{l=1}^{n_i}{d_{lk}^2} \\end{equation} left part equation sum squared distances target object objects cluster. right part equation average squared distances objects cluster. Distance-based eij2e_{ij}^2 equation can generalized case fuzzy cluster: eij2=1∑k=1nuikm∑l=1nidlj2−12(∑k=1nuikm)2∑k=1n∑l=1nuikmuilmdlk2\\begin{equation} e_{ij}^2 = \\frac{1}{\\sum_{k=1}^n{u_{ik}^m}}\\sum_{l=1}^{n_i}{d_{lj}^2}- \\frac{1}{2\\left(\\sum_{k=1}^n{u_{ik}^m}\\right)^2}\\sum_{k=1}^{n}\\sum_{l=1}^{n}{u_{ik}^mu_{il}^md_{lk}^2} \\end{equation} Crisp fuzzy distance-based equations allow Euclidean distance centroid determined without calculating coordinates. Therefore, allow steps #1 #2 combined single step. words, distance-based duals exist centroid-based clustering methods resemblance space comprises Euclidean distances (R. J. Hathaway, Davenport, Bezdek 1989; R. Hathaway, Bezdek, Davenport 1996). transform original data order emulate distance (like chord), duality holds, although centroids defined transformed space. happens values 𝐃\\mathbf{D} calculated using Euclidean distance? Crisp fuzzy distance-based equations also valid dissimilarity measures, although important details remembered. equations assume resemblance space Euclidean (.e. produce negative eigenvalues principal coordinates analysis) centroids appropriate prototypes clusters. dissimilarities Euclidean property oddities may arise (R. J. Hathaway Bezdek 1994). example, possible obtain negative eij2e_{ij}^2 values, specially groups small size. practice, however, negative distances occur can reset zero (De Cáceres, Oliva, Font 2006).","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"creating-classifications-vegclust-and-vegclustdist","dir":"Articles","previous_headings":"Managing vegetation classifications","what":"Creating classifications: vegclust and vegclustdist()","title":"How to use the vegclust package","text":"Functions vegclust vegclustdist() allow vegetation types defined set unlabelled vegetation observations (.e. relevés plot records) using clustering models explained previous section. vegclust requires rectangular site--species matrix, whereas vegclustdist() requires symmetric site--site dissimilarity matrix.","code":""},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"the-k-means-model","dir":"Articles","previous_headings":"Managing vegetation classifications > Creating classifications: vegclust and vegclustdist()","what":"The K-means model","title":"How to use the vegclust package","text":"following piece code produces classification example data set three groups using K-means clustering model: result object class vegclust, fact list several components (method, parameters, prototypes, objective function, etc.): One important components membership matrix 𝐔\\mathbf{U}, show transposed : Another important component matrix containing coordinates cluster centroids (.e. vectors 𝐜i\\mathbf{c}_i cluster): classification exercise can conducted matrix chord distances objects use function vegclustdist() instead vegclust: Note different way specify number clusters. case vegclustdist() obtain cluster centroids, calculated explicitly: obtain cluster memberships: used resemblance space (although different form) examples, vegclust vegclustdist() give result provided algorithm become stuck relative optimum objective function. Although R functions return objects class vegclust, can identify whether calculations done dissimilarities rectangular matrices inspecting ‘mode’ element list: following subsections run vegclust using clustering models, examples made using vegclustdist().","code":"wetland.km = vegclust(x = wetlandchord, mobileCenters=3,                        method=\"KM\", nstart=20) names(wetland.km) #>  [1] \"mode\"          \"method\"        \"m\"             \"dnoise\"        #>  [5] \"eta\"           \"memb\"          \"mobileCenters\" \"fixedCenters\"  #>  [9] \"dist2clusters\" \"withinss\"      \"size\"          \"functional\"    #> [13] \"iter\" t(wetland.km$memb) #>    5 8 13 4 17 3 9 21 16 14 2 15 1 7 10 40 23 25 22 20 6 18 12 39 19 11 30 34 #> M1 0 0  0 0  0 0 0  0  0  0 0  0 0 0  0  1  1  1  1  1 1  1  1  1  1  1  0  0 #> M2 0 0  0 0  0 0 0  0  0  0 0  0 0 0  0  0  0  0  0  0 0  0  0  0  0  0  1  1 #> M3 1 1  1 1  1 1 1  1  1  1 1  1 1 1  1  0  0  0  0  0 0  0  0  0  0  0  0  0 #>    28 31 26 29 33 24 36 37 41 27 32 35 38 #> M1  0  0  1  1  1  0  0  0  0  0  0  0  0 #> M2  1  1  0  0  0  1  1  1  1  1  1  0  0 #> M3  0  0  0  0  0  0  0  0  0  0  0  1  1 round(wetland.km$mobileCenters, dig=3) #>    Abefic Merhed Alyvag Pancam Abemos Melcor Ludoct Eupvac Echpas Passcr Poa2 #> M1  0.000  0.000  0.047  0.076  0.016  0.153  0.000  0.050  0.066  0.000 0.01 #> M2  0.018  0.068  0.000  0.356  0.015  0.275  0.019  0.205  0.102  0.026 0.00 #> M3  0.000  0.000  0.000  0.027  0.000  0.062  0.000  0.039  0.048  0.000 0.00 #>    Carhal Dendio Casobt Aesind Cyprot Ipocop Cynarc Walind Sessp. Phynod Echell #> M1  0.069  0.000  0.000  0.075  0.081  0.013  0.013  0.064  0.104  0.715  0.119 #> M2  0.000  0.000  0.000  0.019  0.176  0.040  0.432  0.078  0.157  0.064  0.112 #> M3  0.037  0.016  0.016  0.000  0.000  0.000  0.000  0.068  0.144  0.000  0.049 #>    Helind Ipoaqu Orysp. Elesp. Psespi Ludads Polatt  Poa1 Helcri Physp. Goopur #> M1  0.172  0.048  0.172  0.138  0.027  0.000  0.000 0.013  0.013  0.000  0.000 #> M2  0.019  0.037  0.040  0.000  0.000  0.000  0.000 0.000  0.000  0.000  0.000 #> M3  0.125  0.055  0.649  0.154  0.192  0.204  0.097 0.000  0.000  0.012  0.012 wetland.kmdist = vegclustdist(x = dchord, mobileMemb=3,                                method=\"KM\", nstart = 20) names(wetland.kmdist) #>  [1] \"mode\"          \"method\"        \"m\"             \"dnoise\"        #>  [5] \"eta\"           \"memb\"          \"mobileCenters\" \"fixedCenters\"  #>  [9] \"dist2clusters\" \"withinss\"      \"size\"          \"functional\" wetland.kmdist$mobileCenters #> NULL t(wetland.kmdist$memb) #>    5 8 13 4 17 3 9 21 16 14 2 15 1 7 10 40 23 25 22 20 6 18 12 39 19 11 30 34 #> M1 0 0  0 0  0 0 0  0  0  0 0  0 0 0  0  0  0  0  0  0 0  0  0  0  0  0  1  1 #> M2 0 0  0 0  0 0 0  0  0  0 0  0 0 0  0  1  1  1  1  1 1  1  1  1  1  1  0  0 #> M3 1 1  1 1  1 1 1  1  1  1 1  1 1 1  1  0  0  0  0  0 0  0  0  0  0  0  0  0 #>    28 31 26 29 33 24 36 37 41 27 32 35 38 #> M1  1  1  0  0  0  1  1  1  1  1  1  0  0 #> M2  0  0  1  1  1  0  0  0  0  0  0  0  0 #> M3  0  0  0  0  0  0  0  0  0  0  0  1  1 wetland.km$mode #> [1] \"raw\" wetland.kmdist$mode #> [1] \"dist\""},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"the-fuzzy-c-means-model","dir":"Articles","previous_headings":"Managing vegetation classifications > Creating classifications: vegclust and vegclustdist()","what":"The Fuzzy C-means model","title":"How to use the vegclust package","text":"Let us inspect distance object cluster centroid: many objects distance cluster assigned much smaller distance clusters. However, objects (‘22’, ‘29’ ‘35’) distance closest cluster center differ much distance second closest one. latter objects well assigned? objects intermediate degrees membership instead picking one cluster arbitrarily? Fuzzy C-means cluster model allows fuzzy memberships obtained alternative crisp memberships: comparison memberships distance clusters shown reveal intermediate objects obtain fuzzier membership values objects. Although FCM theoretically better model KM vegetation classification, vegetation scientists normally interested crisp assignments. function defuzzify() allows fuzzy membership matrix converted crisp one: Another way defuzzifying membership matrix setting threshold minimum fuzzy membership: second defuzzification approach intermediate objects remain unclassified (indicated missing values). important recognise FCM fuzzy membership values depend fuzziness exponent mm. fact, run FCM large mm value obtain uninformative results: uninformative results become obvious defuzzification membership matrix:","code":"round(t(wetland.km$dist2clusters), dig=2) #>       5    8   13    4   17    3    9   21   16   14    2   15    1    7   10 #> M1 1.05 1.10 1.09 1.14 1.11 1.22 1.23 1.09 1.09 1.10 1.12 1.19 1.12 1.15 1.19 #> M2 1.12 1.12 1.14 1.17 1.07 1.22 1.22 1.20 1.17 1.16 1.17 1.21 1.21 1.18 1.23 #> M3 0.54 0.68 0.44 0.45 0.64 0.76 0.95 0.50 0.64 0.46 0.38 0.57 0.47 0.72 0.87 #>      40   23   25   22   20    6   18   12   39   19   11   30   34   28   31 #> M1 0.40 0.60 0.51 0.67 0.56 0.47 0.45 0.40 0.52 0.44 0.64 1.16 1.20 1.15 1.19 #> M2 1.09 1.07 1.12 1.03 1.15 1.06 1.12 1.12 1.06 1.07 1.07 0.86 0.66 0.77 0.69 #> M3 1.11 0.92 0.86 0.73 1.11 1.15 1.19 1.16 1.12 0.97 1.13 1.20 1.22 1.19 1.20 #>      26   29   33   24   36   37   41   27   32   35   38 #> M1 0.81 0.78 0.49 1.04 0.90 1.15 1.14 1.19 1.13 1.03 1.10 #> M2 1.00 0.92 1.00 0.55 0.62 0.55 0.56 0.78 0.73 0.95 0.99 #> M3 1.22 1.17 1.22 1.20 1.18 1.17 0.99 1.22 1.17 0.80 0.68 wetland.fcm = vegclust(x = wetlandchord, mobileCenters=3,                         method=\"FCM\", m=1.2, nstart=20) round(t(wetland.fcm$memb), dig=3) #>        5     8 13 4    17     3     9 21    16 14 2    15 1     7    10 40 #> M1 0.998 0.985  1 1 0.990 0.981 0.844  1 0.993  1 1 0.999 1 0.981 0.920  0 #> M2 0.001 0.007  0 0 0.004 0.009 0.070  0 0.004  0 0 0.001 0 0.011 0.044  1 #> M3 0.001 0.007  0 0 0.007 0.011 0.086  0 0.003  0 0 0.001 0 0.009 0.036  0 #>       23    25    22    20 6 18 12    39 19    11    30    34    28    31    26 #> M1 0.016 0.007 0.404 0.001 0  0  0 0.000  0 0.003 0.031 0.002 0.013 0.003 0.017 #> M2 0.980 0.992 0.582 0.998 1  1  1 0.999  1 0.992 0.040 0.002 0.016 0.003 0.841 #> M3 0.004 0.001 0.014 0.001 0  0  0 0.001  0 0.005 0.928 0.996 0.971 0.993 0.141 #>       29    33    24    36    37    41    27    32    35    38 #> M1 0.017 0.000 0.000 0.001 0.001 0.004 0.012 0.008 0.783 0.970 #> M2 0.742 0.999 0.002 0.020 0.001 0.001 0.015 0.011 0.057 0.006 #> M3 0.241 0.001 0.998 0.978 0.999 0.995 0.973 0.980 0.160 0.024 groups = defuzzify(wetland.fcm)$cluster groups #>    5    8   13    4   17    3    9   21   16   14    2   15    1    7   10   40  #> \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M2\"  #>   23   25   22   20    6   18   12   39   19   11   30   34   28   31   26   29  #> \"M2\" \"M2\" \"M2\" \"M2\" \"M2\" \"M2\" \"M2\" \"M2\" \"M2\" \"M2\" \"M3\" \"M3\" \"M3\" \"M3\" \"M2\" \"M2\"  #>   33   24   36   37   41   27   32   35   38  #> \"M2\" \"M3\" \"M3\" \"M3\" \"M3\" \"M3\" \"M3\" \"M1\" \"M1\" table(groups) #> groups #> M1 M2 M3  #> 17 14 10 groups = defuzzify(wetland.fcm, method = \"cut\", alpha = 0.8)$cluster groups #>    5    8   13    4   17    3    9   21   16   14    2   15    1    7   10   40  #> \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M2\"  #>   23   25   22   20    6   18   12   39   19   11   30   34   28   31   26   29  #> \"M2\" \"M2\"   NA \"M2\" \"M2\" \"M2\" \"M2\" \"M2\" \"M2\" \"M2\" \"M3\" \"M3\" \"M3\" \"M3\" \"M2\"   NA  #>   33   24   36   37   41   27   32   35   38  #> \"M2\" \"M3\" \"M3\" \"M3\" \"M3\" \"M3\" \"M3\"   NA \"M1\" table(groups, useNA = \"always\") #> groups #>   M1   M2   M3 <NA>  #>   16   12   10    3 wetland.fcm2 = vegclust(x = wetlandchord, mobileCenters=3,                         method=\"FCM\", m=10, nstart=20) round(t(wetland.fcm2$memb), dig=3) #>        5     8    13     4    17     3     9    21    16    14     2    15 #> M1 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 #> M2 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 #> M3 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 #>        1     7    10    40    23    25    22    20     6    18    12    39 #> M1 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 #> M2 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 #> M3 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 #>       19    11    30    34    28    31    26    29    33    24    36    37 #> M1 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 #> M2 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 #> M3 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 #>       41    27    32    35    38 #> M1 0.333 0.333 0.333 0.333 0.333 #> M2 0.333 0.333 0.333 0.333 0.333 #> M3 0.333 0.333 0.333 0.333 0.333 groups2 = defuzzify(wetland.fcm2, method = \"cut\", alpha = 0.8)$cluster table(groups2, useNA = \"always\") #> groups2 #> <NA>  #>   41"},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"the-noise-clustering-model","dir":"Articles","previous_headings":"Managing vegetation classifications > Creating classifications: vegclust and vegclustdist()","what":"The Noise clustering model","title":"How to use the vegclust package","text":"previous two models, objects assigned, either completely one cluster membership divided among clusters (words, accepted partition restriction). may appropriate many instances, may cause problems plant communities sampled include rare species assemblages. plant communities appropriately classified ‘outliers’ influence cluster prototypes. noise clustering (NC) model allow outlier objects excluded classification: FCM, objects intermediate memberships. addition, objects high membership Noise class, indicates distant ‘true’ cluster centers. objects can considered ‘outliers’ remain unclassified: Note can defuzzify membership matrix using threshold, , identify intermediates (‘NA’) outliers (members noise class: `N’): vegetation classification, distinguishing intermediate outlier always clearcut. Nevertheless, distinction may useful practice outlier objects may relate vegetation patterns exist study area happen underrepresented sample. , outlier plant communities may rare given vegetation data set , sense new data added belong vegetation type. Alternatively, may represent rare species assemblages study area. Distinguishing one case done without collecting data (Wiser De Cáceres 2012). advantage NC model FCM KM ‘outliers’ influence cluster centers. result, cluster centers separated previous models. Compare following distance matrices cluster centroids: However, particular advantage can also obtained (partitive methods) medoids used prototypes instead centroids (see ).","code":"wetland.nc = vegclust(x = wetlandchord, mobileCenters=3,                        method=\"NC\", m=1.2, dnoise=0.8, nstart=20) round(t(wetland.nc$memb), dig=2) #>       5    8 13 4   17    3    9 21   16   14 2   15 1    7   10 40   23   25 #> M1 0.00 0.00  0 0 0.00 0.01 0.01  0 0.00 0.00 0 0.00 0 0.01 0.01  0 0.00 0.00 #> M2 0.99 0.85  1 1 0.93 0.41 0.08  1 0.86 0.99 1 0.93 1 0.49 0.12  0 0.01 0.01 #> M3 0.00 0.00  0 0 0.00 0.01 0.01  0 0.00 0.00 0 0.00 0 0.01 0.01  1 0.93 0.98 #> N  0.01 0.14  0 0 0.07 0.58 0.90  0 0.13 0.01 0 0.07 0 0.49 0.86  0 0.06 0.01 #>      22   20 6 18 12   39 19   11   30   34   28   31   26   29   33 24 36 37 #> M1 0.00 0.00 0  0  0 0.00  0 0.00 0.07 0.98 0.08 0.98 0.03 0.08 0.00  1  1  1 #> M2 0.50 0.00 0  0  0 0.00  0 0.00 0.01 0.00 0.01 0.00 0.01 0.01 0.00  0  0  0 #> M3 0.39 0.98 1  1  1 0.99  1 0.93 0.01 0.00 0.02 0.00 0.28 0.34 0.99  0  0  0 #> N  0.11 0.02 0  0  0 0.01  0 0.06 0.90 0.02 0.89 0.02 0.68 0.58 0.01  0  0  0 #>      41   27   32   35   38 #> M1 0.93 0.05 0.11 0.02 0.00 #> M2 0.01 0.01 0.01 0.48 0.90 #> M3 0.00 0.01 0.02 0.03 0.00 #> N  0.06 0.92 0.85 0.47 0.09 groups = defuzzify(wetland.nc)$cluster groups #>    5    8   13    4   17    3    9   21   16   14    2   15    1    7   10   40  #> \"M2\" \"M2\" \"M2\" \"M2\" \"M2\"  \"N\"  \"N\" \"M2\" \"M2\" \"M2\" \"M2\" \"M2\" \"M2\"  \"N\"  \"N\" \"M3\"  #>   23   25   22   20    6   18   12   39   19   11   30   34   28   31   26   29  #> \"M3\" \"M3\" \"M2\" \"M3\" \"M3\" \"M3\" \"M3\" \"M3\" \"M3\" \"M3\"  \"N\" \"M1\"  \"N\" \"M1\"  \"N\"  \"N\"  #>   33   24   36   37   41   27   32   35   38  #> \"M3\" \"M1\" \"M1\" \"M1\" \"M1\"  \"N\"  \"N\" \"M2\" \"M2\" table(groups) #> groups #> M1 M2 M3  N  #>  6 14 11 10 groups = defuzzify(wetland.nc, method=\"cut\", alpha=0.8)$cluster groups #>    5    8   13    4   17    3    9   21   16   14    2   15    1    7   10   40  #> \"M2\" \"M2\" \"M2\" \"M2\" \"M2\"   NA  \"N\" \"M2\" \"M2\" \"M2\" \"M2\" \"M2\" \"M2\"   NA  \"N\" \"M3\"  #>   23   25   22   20    6   18   12   39   19   11   30   34   28   31   26   29  #> \"M3\" \"M3\"   NA \"M3\" \"M3\" \"M3\" \"M3\" \"M3\" \"M3\" \"M3\"  \"N\" \"M1\"  \"N\" \"M1\"   NA   NA  #>   33   24   36   37   41   27   32   35   38  #> \"M3\" \"M1\" \"M1\" \"M1\" \"M1\"  \"N\"  \"N\"   NA \"M2\" table(groups, useNA = \"always\") #> groups #>   M1   M2   M3    N <NA>  #>    6   12   11    6    6 dist(wetland.km$mobileCenters) #>           M1        M2 #> M2 0.8997438           #> M3 0.9248370 0.9567205 dist(wetland.fcm$mobileCenters) #>           M1        M2 #> M2 0.9280498           #> M3 0.9387465 0.8852144 dist(wetland.nc$mobileCenters) #>           M1        M2 #> M2 1.0666331           #> M3 1.0102841 0.9735451"},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"medoid-based-clustering","dir":"Articles","previous_headings":"Managing vegetation classifications > Creating classifications: vegclust and vegclustdist()","what":"Medoid-based clustering","title":"How to use the vegclust package","text":"examples shown far repeated using medoids cluster prototypes instead centroids. example, K-medoids (K-means analogue) : ran using site--species matrix input, vegclust() returns coordinates medoids cluster centers: However, using site--site dissimilarity matrices input vegclustdist(), indices objects returned instead:","code":"wetland.kmdd = vegclust(x = wetlandchord, mobileCenters=3,                        method=\"KMdd\", nstart=20) t(wetland.kmdd$memb) #>    5 8 13 4 17 3 9 21 16 14 2 15 1 7 10 40 23 25 22 20 6 18 12 39 19 11 30 34 #> M1 0 0  0 0  0 0 0  0  0  0 0  0 0 0  0  0  0  0  0  0 0  0  0  0  0  0  1  1 #> M2 1 1  1 1  1 1 1  1  1  1 1  1 1 1  1  0  0  0  1  0 0  0  0  0  0  0  0  0 #> M3 0 0  0 0  0 0 0  0  0  0 0  0 0 0  0  1  1  1  0  1 1  1  1  1  1  1  0  0 #>    28 31 26 29 33 24 36 37 41 27 32 35 38 #> M1  1  1  0  0  0  1  1  1  1  1  1  0  0 #> M2  0  0  0  0  0  0  0  0  0  0  0  1  1 #> M3  0  0  1  1  1  0  0  0  0  0  0  0  0 round(wetland.kmdd$mobileCenters, dig=3) #>    Abefic Merhed Alyvag Pancam Abemos Melcor Ludoct Eupvac Echpas Passcr Poa2 #> M1      0      0      0  0.258      0  0.258      0  0.258      0  0.258    0 #> M2      0      0      0  0.000      0  0.183      0  0.000      0  0.000    0 #> M3      0      0      0  0.000      0  0.177      0  0.000      0  0.000    0 #>    Carhal Dendio Casobt Aesind Cyprot Ipocop Cynarc Walind Sessp. Phynod Echell #> M1  0.000      0      0      0      0      0  0.775      0  0.258  0.258  0.000 #> M2  0.000      0      0      0      0      0  0.000      0  0.000  0.000  0.000 #> M3  0.177      0      0      0      0      0  0.000      0  0.000  0.884  0.177 #>    Helind Ipoaqu Orysp. Elesp. Psespi Ludads Polatt Poa1 Helcri Physp. Goopur #> M1  0.000  0.000  0.000  0.000  0.000  0.000  0.000    0      0      0      0 #> M2  0.000  0.000  0.913  0.183  0.183  0.183  0.183    0      0      0      0 #> M3  0.177  0.177  0.000  0.177  0.177  0.000  0.000    0      0      0      0 wetland.kmdd = vegclustdist(x = dchord, mobileMemb=3,                        method=\"KMdd\", nstart=20) wetland.kmdd$mobileCenters #> [1] 11 34 23"},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"supervised-classification-as-vegclust-and-vegclass","dir":"Articles","previous_headings":"Managing vegetation classifications","what":"Supervised classification: as.vegclust() and vegclass()","title":"How to use the vegclust package","text":"Vegetation types meant used. example, new area may surveyed map vegetation types may needed. simulate process assigning new observations vegetation classification created priori. order simulate two-step process, split example data set two matrices, one 31 objects whose group classification known priori 10 objects whose classification studied: initial classification, simply take two groups resulting K-means analysis (using function kmeans() stats package) first data set: idea know whether ten objects second data set may assigned vegetation types defined using first data set. initial classification obtained using function vegclust(), need transform input classification 31 objects object class vegclust. done using function .vegclust(): Note specify clustering model vegclust object. default, clustering method K-means (KM): case, matches way obtained initial classification. general, however, may classification obtained following informal (unknown) procedure, choose clustering model according preferences assignments. object vegclust can use function vegclass() assign second set observations according membership rule k-means cluster model: procedure can repeated using dissimilarity matrices. First, call .vegclust() create vegclust object: , need matrix distances set observations assigned original set 31 observations. can obtained original distance matrix including pairs observations: two objects can use function vegclass() assign second set observations according membership rule k-means cluster model: Note cases objects second set assigned nearest cluster. want determine whether appropriate objects define new vegetation type? case, may better using noise clustering. can choose, example, hard noise clustering (HNC) model: additional parameter needed: distance noise class ‘dnoise’, δ\\delta. can set either conventionally (depending level abstraction vegetation types) relying variance original clusters (De Cáceres, Oliva, Font 2006). results noise clustering model show several ten objects assigned noise class (‘N’), indicates used define new cluster.","code":"wetland.31 = wetlandchord[1:31,] wetland.31 = wetland.31[,colSums(wetland.31)>0] dim(wetland.31) #> [1] 31 27 wetland.10 = wetlandchord[-(1:31),] wetland.10 = wetland.10[,colSums(wetland.10)>0]  dim(wetland.10) #> [1] 10 22 km = kmeans(wetland.31, 2) groups = km$cluster groups #>  5  8 13  4 17  3  9 21 16 14  2 15  1  7 10 40 23 25 22 20  6 18 12 39 19 11  #>  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  1  1  1  1  1  1  1  1  1  1  1  #> 30 34 28 31 26  #>  1  1  1  1  1 wetland.31.km = as.vegclust(wetland.31, groups) wetland.31.km$method #> [1] \"KM\" wetland.10.km = vegclass(wetland.31.km, wetland.10) defuzzify(wetland.10.km)$cluster #>  29  33  24  36  37  41  27  32  35  38  #> \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"2\" \"2\" wetland.31.km.d = as.vegclust(dist(wetland.31), groups) wetland.d.10.31 = as.data.frame(as.matrix(dchord)[32:41,1:31]) wetland.d.11.km = vegclass(wetland.31.km.d,wetland.d.10.31) defuzzify(wetland.d.11.km)$cluster #>  29  33  24  36  37  41  27  32  35  38  #> \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"2\" \"2\" wetland.31.nc = as.vegclust(wetland.31, groups, method=\"HNC\",                              dnoise = 0.8) wetland.10.nc = vegclass(wetland.31.nc, wetland.10) defuzzify(wetland.10.nc)$cluster #>  29  33  24  36  37  41  27  32  35  38  #> \"1\" \"1\" \"N\" \"1\" \"N\" \"N\" \"N\" \"N\" \"N\" \"2\""},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"extending-vegetation-classifications","dir":"Articles","previous_headings":"Managing vegetation classifications","what":"Extending vegetation classifications","title":"How to use the vegclust package","text":"Allowing vegetation classifications dynamic entities, sense may modified extended new surveys conducted (general, new data becomes available) increases usability (De Cáceres, Font, Oliva 2010; Wiser De Cáceres 2012). aim preserve two prototypes initial classification let vegclust define new vegetation type.","code":""},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"conforming-vegetation-data-sets","dir":"Articles","previous_headings":"Managing vegetation classifications > Extending vegetation classifications","what":"Conforming vegetation data sets","title":"How to use the vegclust package","text":"new vegetation data becomes available, set species new data set normally set species used original classification exercise. situation, practitioner needs bring two sets samples resemblance space. example divided initial data set two subsets 31 10 sites, respectively (.e. wetland.31 wetland.10). Thus, original data set common set species. However, now pretend wetland.31 wetland.10 obtained independently. useful function create common space species two sets vegetation observations conformveg(): difference new objects preceeding ones include extra columns zeros, set columns (.e. species) match two data sets.","code":"cf = conformveg(wetland.31, wetland.10) wetland.31.cf<- cf$x wetland.10.cf<- cf$y dim(wetland.31.cf) #> [1] 31 33 dim(wetland.10.cf) #> [1] 10 33"},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"re-calculating-the-centroids-of-the-initial-classification","dir":"Articles","previous_headings":"Managing vegetation classifications > Extending vegetation classifications","what":"Re-calculating the centroids of the initial classification","title":"How to use the vegclust package","text":"Another step need conduct calling vegclust re-calculate centroids initial classification resemblance space species. Thus, need call clustcentroid() using conformed data set input: , centroids exactly like original ones except expressed matrix includes extra zeros new species.","code":"fixed = clustcentroid(wetland.31.cf, groups)"},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"calling-vegclust-with-fixed-prototypes","dir":"Articles","previous_headings":"Managing vegetation classifications > Extending vegetation classifications","what":"Calling vegclust with fixed prototypes","title":"How to use the vegclust package","text":"point ready call function vegclust() new data set (, conformed version): , function vegclust() renamed original clusters ‘F2’ ‘F3’ (indicating now fixed), new cluster named ‘M1’. Instead relying Noise clustering model, chosen use K-means model extend classification: avoids objects Noise class. However, note noise clustering model allows objects Noise classified later new data becomes available, instead forcing belong one cluster (.e. partition restriction).","code":"wetland.nc = vegclust(wetland.10.cf, mobileCenters=1,                        fixedCenters = fixed,                        method = wetland.31.nc$method,                       dnoise=wetland.31.nc$dnoise, nstart=10) defuzzify(wetland.nc)$cluster #>   29   33   24   36   37   41   27   32   35   38  #> \"F2\" \"F2\" \"M1\" \"M1\" \"M1\" \"M1\"  \"N\"  \"N\"  \"N\" \"F3\" wetland.km = vegclust(wetland.10.cf, mobileCenters=1,                        fixedCenters = fixed,                        method = \"KM\",                       nstart=10) defuzzify(wetland.km)$cluster #>   29   33   24   36   37   41   27   32   35   38  #> \"F2\" \"F2\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"F3\" \"F3\""},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"extending-or-refining-classifications","dir":"Articles","previous_headings":"Managing vegetation classifications > Extending vegetation classifications","what":"Extending or refining classifications?","title":"How to use the vegclust package","text":"Instead calling vegclust() new data set , chosen use set vegetation observations: Note objects first data set may reassigned (different cluster Noise class). centroids original classification preserved, membership particular objects may change classification now includes new prototypes objects may assigned. Using complete data set instead new data implies used ready accept reassignments. new memberships strikingly different original ones, one might decide start three group classification scratch.","code":"wetland.nc = vegclust(rbind(wetland.31.cf,wetland.10.cf), mobileCenters=1,                        fixedCenters = fixed,                        method = wetland.31.nc$method,                       dnoise=wetland.31.nc$dnoise, nstart=10) defuzzify(wetland.nc)$cluster #>    5    8   13    4   17    3    9   21   16   14    2   15    1    7   10   40  #> \"F3\" \"F3\" \"F3\" \"F3\" \"F3\" \"F3\"  \"N\" \"F3\" \"F3\" \"F3\" \"F3\" \"F3\" \"F3\" \"F3\"  \"N\" \"F2\"  #>   23   25   22   20    6   18   12   39   19   11   30   34   28   31   26   29  #> \"F2\" \"F2\" \"M1\" \"F2\" \"F2\" \"F2\" \"F2\" \"F2\" \"F2\" \"F2\"  \"N\"  \"N\"  \"N\"  \"N\" \"F2\" \"F2\"  #>   33   24   36   37   41   27   32   35   38  #> \"F2\"  \"N\" \"F2\"  \"N\"  \"N\"  \"N\"  \"N\" \"M1\" \"M1\""},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"using-vegclustdist-with-fixed-prototypes","dir":"Articles","previous_headings":"Managing vegetation classifications > Extending vegetation classifications","what":"Using vegclustdist() with fixed prototypes","title":"How to use the vegclust package","text":"Extending vegetation classifications can also done distance-based mode. case explicit coordinates fixed prototypes, may distances centers. begin example use distances two clusters obtained stage assigning new observations: information, can now call vegclustdist() define new cluster accounting previous ones: Analogously vegclust, chosen use set vegetation observations. case, need pool distances centers: call vegclustdist() using full distance matrix: , objects may reclassified different clusters using option.","code":"fixedDist = wetland.d.11.km$dist2clusters wetland.km.d = vegclustdist(dist(wetland.10), mobileMemb = 1,                             fixedDistToCenters=fixedDist,                              method = \"KM\",                             nstart=10) defuzzify(wetland.km.d)$cluster #>   29   33   24   36   37   41   27   32   35   38  #> \"F2\" \"F2\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"F3\" \"F3\" fixedDist = rbind(wetland.31.km.d$dist2clusters, wetland.d.11.km$dist2clusters) wetland.km.d = vegclustdist(dchord, mobileMemb = 1,                             fixedDistToCenters=fixedDist,                              method = \"KM\",                             nstart=10) defuzzify(wetland.km.d)$cluster #>    5    8   13    4   17    3    9   21   16   14    2   15    1    7   10   40  #> \"F3\" \"F3\" \"F3\" \"F3\" \"F3\" \"F3\" \"F3\" \"F3\" \"F3\" \"F3\" \"F3\" \"F3\" \"F3\" \"F3\" \"F3\" \"F2\"  #>   23   25   22   20    6   18   12   39   19   11   30   34   28   31   26   29  #> \"F2\" \"F2\" \"F2\" \"F2\" \"F2\" \"F2\" \"F2\" \"F2\" \"F2\" \"F2\" \"M1\" \"M1\" \"M1\" \"M1\" \"F2\" \"F2\"  #>   33   24   36   37   41   27   32   35   38  #> \"F2\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"F3\" \"F3\""},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"cluster-characterization","dir":"Articles","previous_headings":"","what":"Cluster characterization","title":"How to use the vegclust package","text":"section show use auxiliary functions allow cluster properties extracted input classification. examples use priori classification data set:","code":"groups = c(rep(1, 17), rep(2, 14), rep(3,10))"},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"cluster-prototypes-clustcentroid-and-clustmedoid","dir":"Articles","previous_headings":"Cluster characterization","what":"Cluster prototypes: clustcentroid() and clustmedoid()","title":"How to use the vegclust package","text":"Functions clustcentroid() clustmedoid() allow cluster prototypes calculated according input classification structure, can specified using either cluster vector membership matrix. example, clustcentroid() can calculate coordinates centroids initial groups using: medoids prototypes chosen among objects classified, function clustmedoid() return coordinates indices objects. following code uses medoid hard cluster equation determine medoids cluster: value returned function medoid() vector indices corresponding object names (numbers particular case). classification structure fuzzy membership matrix, cluster centroids medoids determined using fuzzy centroid fuzzy medoid equation, respectively.","code":"centroids = clustcentroid(wetlandchord, groups) round(centroids, dig=3) #>   Abefic Merhed Alyvag Pancam Abemos Melcor Ludoct Eupvac Echpas Passcr Poa2 #> 1  0.000  0.000  0.009  0.009  0.000  0.054  0.000  0.020  0.031  0.000 0.00 #> 2  0.013  0.015  0.036  0.088  0.000  0.178  0.000  0.090  0.116  0.000 0.01 #> 3  0.000  0.047  0.000  0.371  0.036  0.253  0.019  0.182  0.061  0.026 0.00 #>   Carhal Dendio Casobt Aesind Cyprot Ipocop Cynarc Walind Sessp. Phynod Echell #> 1  0.064  0.000  0.016  0.009  0.000  0.000  0.000  0.068  0.144  0.090  0.022 #> 2  0.036  0.000  0.000  0.064  0.179  0.028  0.106  0.055  0.117  0.506  0.119 #> 3  0.000  0.027  0.000  0.019  0.039  0.018  0.301  0.090  0.138  0.204  0.158 #>   Helind Ipoaqu Orysp. Elesp. Psespi Ludads Polatt  Poa1 Helcri Physp. Goopur #> 1  0.112  0.055  0.609  0.164  0.192  0.204  0.097 0.000  0.000   0.00   0.00 #> 2  0.138  0.048  0.126  0.125  0.027  0.000  0.000 0.013  0.013   0.00   0.00 #> 3  0.090  0.037  0.172  0.000  0.000  0.000  0.000 0.000  0.000   0.02   0.02 medoids = clustmedoid(wetlandchord, groups) medoids #>  2 12 41  #> 11 23 37"},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"cluster-internal-variability-clustvar","dir":"Articles","previous_headings":"Cluster characterization","what":"Cluster internal variability: clustvar()","title":"How to use the vegclust package","text":"Vegetation types may differ internal variability. function clustvar() allows amount compositional variation (.e. beta diversity) observed among sites sites belonging cluster determined. clusters whose prototype centroid, calculated mean squared distances object group group centroid. example, variability given group ii : Var()=∑j=1nkeij2/ni\\begin{equation} Var() = \\sum_{j=1}^{n_k}{e_{ij}^2}/n_i \\end{equation} Note division nin_i (ni−1)(n_i-1), give unbiased sample estimate. Thus, variances calculated clustvar() population variances. example, variances three groups examples : reason population values produced, instead sample estimates, allows variance calculated using fuzzy membership values: Var()=∑j=1nuijmeij2∑j=1nuijm\\begin{equation} Var() = \\frac{\\sum_{j=1}^{n}u_{ij}^me_{ij}^2}{\\sum_{j=1}^n{u_{ij}^m}} \\end{equation} Cluster variances can also obtained using distance dissimilarity matrices. case, variance given group calculated : Var()=1ni2∑k=1ni∑l=1nidkl2\\begin{equation} Var() = \\frac{1}{n_i^2} \\sum_{k=1}^{n_i}\\sum_{l=1}^{n_i}{d_{kl}^2} \\end{equation} , division ni(ni−1)n_i(n_i-1) instead ni2n_i^2 give unbiased variance estimate. example community data transformed using chord transformation, variance values can obtained using distance matrix chord distances: Finally, classification structure provided function clustvar() return overall variance (beta diversity) data table:","code":"clustvar(wetlandchord, groups) #>         1         2         3  #> 0.4554668 0.5466579 0.5293836 clustvar(dchord, groups) #>         1         2         3  #> 0.4554668 0.5466579 0.5293836 clustvar(wetlandchord) #> [1] 0.6751038"},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"distance-between-clusters-interclustdist","dir":"Articles","previous_headings":"Cluster characterization","what":"Distance between clusters: interclustdist()","title":"How to use the vegclust package","text":"Calculating distance pairs cluster prototypes useful determine vegetation types similar distinct. prototypes vegetation types chosen cluster medoids, resemblance vegetation types can defined resemblance corresponding medoids: contrast, prototypes vegetation types chosen cluster centroids, distance two vegetation types defined distance cluster centroids. Following example, can simply use function dist() matrix centroid coordinates: Alternatively, function interclustdist() allows distance pairs centroids calculated without coordinates centroids supplied. Instead, matrix distances objects used. example, distance centroids groups ii jj desired, can calculate squared distance : d2(,j)=∑k=1n∑l=1nuikmujlmdkl2∑k=1nuikm∑l=1nujlm−Var()−Var(j)\\begin{equation} d^2(,j)=\\frac{\\sum_{k=1}^{n}\\sum_{l=1}^{n}{u_{ik}^mu_{jl}^m{d_{kl}}^2}}{\\sum_{k=1}^n{u_{ik}^m}\\sum_{l=1}^n{u_{jl}^m}} - Var() - Var(j) \\end{equation} Using former equation example result : returns values .","code":"as.dist(as.matrix(dchord)[medoids,medoids]) #>           2       12 #> 12 1.344006          #> 41 1.093926 1.363297 dist(centroids) #>           1         2 #> 2 0.7624211           #> 3 0.8004329 0.5298008 interclustdist(dchord,groups) #>           1         2 #> 2 0.7624211           #> 3 0.8004329 0.5298008"},{"path":"https://emf-creaf.github.io/vegclust/articles/VegetationClassification.html","id":"constancy-classes-clustconst","dir":"Articles","previous_headings":"Cluster characterization","what":"Constancy classes: clustconst()","title":"How to use the vegclust package","text":"One way characterizing vegetation type examine frequently species occurs vegetation observations belonging type. frequency often called constancy table contains constancy species vegetation types called constancy table. function clustconst() allows table calculated: R object returned clustconst() can examined several ways. First, useful print constancy table ordering species high low constancy cluster: Alternatively, can examine constancy vector vegetation type:","code":"c = clustconst(wetlandchord, memb = as.memb(groups)) d=summary(c, mode=\"all\") #> ------------ 3 ------------- #>            3     2     1 #> Pancam 1.000 0.357 0.059 #> Melcor 1.000 0.786 0.294 #> Eupvac 0.800 0.357 0.118 #> Sessp. 0.600 0.500 0.412 #> Echell 0.600 0.357 0.118 #> ------------ 2 ------------- #>            3     2     1 #> Phynod 0.400 0.714 0.118 #> Helind 0.300 0.643 0.471 #> Elesp. 0.000 0.571 0.529 #> ------------ 1 ------------- #>            3     2     1 #> Orysp. 0.300 0.286 1.000 #> Ludads 0.000 0.000 0.824 summary(c, mode=\"cluster\", name=names(c)[1]) #> Orysp. 1.000  #> Ludads 0.824  #> Elesp. 0.529"},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Miquel De Cáceres. Author, maintainer.","code":""},{"path":"https://emf-creaf.github.io/vegclust/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"De Caceres M, Font X, Oliva F (2010). “management vegetation classifications fuzzy clustering.” Journal Vegetation Science, 21, 1138-1151. doi:10.1111/j.1654-1103.2010.01211.x. De Caceres M, Legendre P, F (2013). “Dissimilarity measurements size structure ecological communities.” Methods Ecology Evolution, 4, 1167-1177. doi:10.1111/2041-210X.12116.","code":"@Article{,   title = {The management of vegetation classifications with fuzzy clustering},   author = {Miquel {De Caceres} and Xavier Font and Francesc Oliva},   journal = {Journal of Vegetation Science},   year = {2010},   volume = {21},   pages = {1138-1151},   doi = {10.1111/j.1654-1103.2010.01211.x}, } @Article{,   title = {Dissimilarity measurements and the size structure of ecological communities},   author = {Miquel {De Caceres} and Pierre Legendre and Fangliang He},   journal = {Methods in Ecology and Evolution},   year = {2013},   volume = {4},   pages = {1167-1177},   doi = {10.1111/2041-210X.12116}, }"},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"Fuzzy Clustering of Vegetation Data","text":"Package vegclust package designed assist analyses vegetation structure composition. intended useful community ecologists forest engineers, clustering functions can used fields. package provides functions : Perform fuzzy clustering vegetation data (De Cáceres et al. 2010). Assess ecological community ressemblance basis structure composition (De Cáceres et al. 2013).","code":""},{"path":"https://emf-creaf.github.io/vegclust/index.html","id":"package-installation","dir":"","previous_headings":"","what":"Package installation","title":"Fuzzy Clustering of Vegetation Data","text":"Package vegclust can found CRAN package repository. addition, latest stable vegclust R package can installed GitHub follows: Additionally, users can help run package functions directly package vignettes, forcing inclusion installation:","code":"devtools::install_github(\"emf-creaf/vegclust\") devtools::install_github(\"emf-creaf/vegclust\",                           build_opts = c(\"--no-resave-data\", \"--no-manual\"),                          build_vignettes = TRUE)"},{"path":"https://emf-creaf.github.io/vegclust/index.html","id":"note-about-community-trajectory-analysis","dir":"","previous_headings":"","what":"Note about ‘Community Trajectory Analysis’","title":"Fuzzy Clustering of Vegetation Data","text":"ver. 2.0, package vegclust included functions conduct Community Trajectory Analysis (CTA). Since ver. 2.0 functions moved independent package ecotraj available https://github.com/emf-creaf/ecotraj/ also CRAN.","code":""},{"path":"https://emf-creaf.github.io/vegclust/index.html","id":"maintenance","dir":"","previous_headings":"","what":"Maintenance","title":"Fuzzy Clustering of Vegetation Data","text":"Although active development, R package maintained Ecosystem Modelling Facility unit CREAF (Spain).","code":""},{"path":"https://emf-creaf.github.io/vegclust/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Fuzzy Clustering of Vegetation Data","text":"De Cáceres, M., Font, X., & Oliva, F. 2010. management vegetation classifications fuzzy clustering. Journal Vegetation Science 21: 1138–1151 (https://doi.org/10.1111/j.1654-1103.2010.01211.x). De Cáceres, M., Legendre, P., & , F. 2013. Dissimilarity measurements size structure ecological communities (D. Faith, Ed.). Methods Ecology Evolution 4: 1167–1177 (https://doi.org/10.1111/2041-210X.12116).","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/CAP.html","id":null,"dir":"Reference","previous_headings":"","what":"Cumulative abundance profile (CAP) — CAP","title":"Cumulative abundance profile (CAP) — CAP","text":"Functions calculate cumulative abundance profiles (CAPs), build matrices , summarize several profiles.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/CAP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cumulative abundance profile (CAP) — CAP","text":"","code":"CAP(x, transform = NULL, verbose = FALSE)  CAP2matrix(CAP, type = \"cumulative\", classWeights = NULL)  CAPcenters(CAP, y = NULL)  CAPquantile(CAP, q = 0.5, y = NULL)"},{"path":"https://emf-creaf.github.io/vegclust/reference/CAP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cumulative abundance profile (CAP) — CAP","text":"x stratified vegetation data set (see function stratifyvegdata). transform function name function applied cumulative abundance value. verbose logical flag indicate extra output. CAP object class 'CAP'. type type information resulting matrix contain. Either \"profile\", \"abundance\" \"volume\". classWeights numerical vector containing weight size class. NULL, classes assumed weight. y vector used factor calculate average quantile profiles per level. Alternatively, object class vegclust CAP centroids medoids desired. q Probability value quantile desired. default median given.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/CAP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cumulative abundance profile (CAP) — CAP","text":"Function CAP returns object class 'CAP', similar objects class 'stratifiedvegdata' abundance values upper size classes beed added lower size classes. Function CAP2matrix returns matrix species rows (columns depend value type). Functions CAPcenters CAPquantile return object class 'CAP'.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/CAP.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cumulative abundance profile (CAP) — CAP","text":"Function CAP replaces abundance value size class sum abundances larger size classes (strata). Thus, upper classes contain smaller abundance values lower classes, creating cumulative abundance profile. Function CAP2matrix takes object class 'CAP' returns data matrix, values differ depending parameter type: (1) type=\"cumulative\" simply reshapes 'CAP' object (list) matrix many rows plot records columns organized blocks (many blocks species block many columns size classes); (2) type=\"total\" returns plot--species matrix value total abundance species plot (.e. CAP value ground level); (3) type=\"volume\" returns plot--species matrix value sum CAP values across size classes (measure \"volume\" occupied species plot). provided, classWeights used weight size classes cumulative abundance profiles ((1) (3) ). Function CAPcenters calculates average abundance profile set plot records. y factor, used speficy groups samples average profiles calculated. y object class 'vegclust' function returns CAP centroids medoids corresponding clustering result. Function CAPquantile calculates quantile profile set CAPs. usage y CAPcenters.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/CAP.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cumulative abundance profile (CAP) — CAP","text":"De Cáceres, M., Legendre, P. & , F. (2013) Dissimilarity measurements size structure ecological communities. Methods Ecology Evolution 4: 1167-1177. De Cáceres, M., Coll, L., Martín-Alcón, S., González-Olabarria, J.R. (submitted) general method classification forest stands using structure composition.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/CAP.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cumulative abundance profile (CAP) — CAP","text":"Miquel De Cáceres, CREAF.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/CAP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cumulative abundance profile (CAP) — CAP","text":"","code":"## Load stratified data data(medreg)  ## Check that 'medreg' has correct class class(medreg) #> [1] \"stratifiedvegdata\" \"list\"               ## Look at the data for the third plot medreg[[3]] #>                                1    2    3    4    5 6 7 #> Pine trees                   0.0 12.5  0.0  0.0  0.0 0 0 #> Quercus trees                0.0  0.0 12.5 12.5 12.5 0 0 #> Tall shrubs and small trees  0.0 25.0 62.5 25.0  0.0 0 0 #> Scrubs and small shrubs      0.0 50.0  0.0  0.0  0.0 0 0 #> Grass                       37.5  0.0  0.0  0.0  0.0 0 0  ## Create cumulative abundance profile (CAP) for each plot medreg.CAP <- CAP(medreg)  ## Look at the profile of the third plot medreg.CAP[[3]] #>                                 1     2    3  4    5 6 7 #> Pine trees                   12.5  12.5  0.0  0  0.0 0 0 #> Quercus trees                37.5  37.5 37.5 25 12.5 0 0 #> Tall shrubs and small trees 112.5 112.5 87.5 25  0.0 0 0 #> Scrubs and small shrubs      50.0  50.0  0.0  0  0.0 0 0 #> Grass                        37.5   0.0  0.0  0  0.0 0 0  ## Create matrix with species abundances medreg.X <- CAP2matrix(medreg.CAP, type=\"total\") head(medreg.X) #>   Pine trees Quercus trees Tall shrubs and small trees Scrubs and small shrubs #> 1        0.0          37.5                        87.5                    50.0 #> 2        0.0           0.0                        87.5                    25.0 #> 3       12.5          37.5                       112.5                    50.0 #> 4       12.5          25.0                        62.5                    37.5 #> 5        0.0          25.0                        75.0                    25.0 #> 6       12.5          37.5                        87.5                    37.5 #>   Grass #> 1  50.0 #> 2  12.5 #> 3  37.5 #> 4  50.0 #> 5  37.5 #> 6  50.0  ## Generate and plot average profile average.CAP <- CAPcenters(medreg.CAP) plot(average.CAP)   ## Generate and plot median profile median.CAP <- CAPquantile(medreg.CAP, q = 0.5) plot(median.CAP)"},{"path":"https://emf-creaf.github.io/vegclust/reference/CAS.html","id":null,"dir":"Reference","previous_headings":"","what":"Cumulative abundance surface (CAS) — CAS","title":"Cumulative abundance surface (CAS) — CAS","text":"Functions calculate cumulative abundance surfaces (CASs), build matrices , summarize several CASs.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/CAS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cumulative abundance surface (CAS) — CAS","text":"","code":"CAS(x, transform = NULL, verbose = FALSE)  CAS2matrix(CAS, type = \"cumulative\", classWeights = NULL)  CAScenters(CAS, y = NULL)  CASmargin(CAS, margin = 1, verbose = FALSE)  CASquantile(CAS, q = 0.5, y = NULL)"},{"path":"https://emf-creaf.github.io/vegclust/reference/CAS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cumulative abundance surface (CAS) — CAS","text":"x object class 'doublestratifiedvegdata' (see function stratifyvegdata). transform function name function applied cumulative abundance value. verbose logical flag indicate extra output. CAS object class 'CAS'. type type information resulting matrix contain (either \"cummulative\" \"total\"). classWeights numerical matrix containing weight combination size classes. NULL, classes assumed weight. y vector used factor calculate average quantile surfaces per level. Alternatively, object class vegclust CAS centroids medoids desired. margin Indicates whether marginalization done primary (margin = 1) secondary (margin = 2) size classes. q Probability value quantile desired. default median given.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/CAS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cumulative abundance surface (CAS) — CAS","text":"Function CAS returns object class 'CAS', similar objects class 'doublestratifiedvegdata' abundance values upper size classes beed added lower size classes. Function CAS2matrix returns matrix species rows (columns depend value type). Functions CAScenters CASquantile return object class 'CAS'.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/CAS.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cumulative abundance surface (CAS) — CAS","text":"Function CAS replaces abundance value combination size classes sum abundances larger size classes. creates cumulative abundance surface (similar bivariant cummulative distribution function). Function CASmargin takes object class 'CAS' returns object class 'CAP' corresponds marginal profile either primary secondary size classes. Function CAS2matrix takes object class 'CAS' returns data matrix, values differ depending parameter type: (1) type=\"cummulative\" simply reshapes 'CAS' object (list) matrix many rows plot records columns organized blocks (many blocks species block many columns combinations size classes); (2) type=\"total\" returns plot--species matrix value total abundance species plot (.e. CAS value ground level). provided, classWeights used weight size classes cumulative abundance surfaces ((1) ). Function CAScenters calculates average abundance surface set plot records. y factor, used speficy groups samples average profiles calculated. y object class 'vegclust' function returns CAS centroids medoids corresponding clustering result. Function CASquantile calculates quantile surface set CASs. usage y CAScenters.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/CAS.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cumulative abundance surface (CAS) — CAS","text":"De Cáceres, M., Legendre, P. & , F. (2013) Dissimilarity measurements size structure ecological communities. Methods Ecology Evolution 4: 1167-1177. De Cáceres, M., Coll, L., Martín-Alcón, S., González-Olabarria, J.R. (submitted) general method classification forest stands using structure composition.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/CAS.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cumulative abundance surface (CAS) — CAS","text":"Miquel De Cáceres, CREAF.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/CAS.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cumulative abundance surface (CAS) — CAS","text":"","code":"## Load tree data data(treedata)  ## Define stratum thresholds (4 strata) heights <- seq(0,4, by=0.5) diameters <- seq(0,2, by=0.5)  ## Stratify tree data using heights and diameters as structural variables X <- stratifyvegdata(treedata, sizes1=heights, sizes2=diameters, plotColumn=\"plotID\",                     speciesColumn=\"species\", size1Column=\"height\", size2Column=\"diam\",                     counts=TRUE) X[[2]] #> , , [0,0.5] #>  #>   [0,0.5] (0.5,1] (1,1.5] (1.5,2] (2,2.5] (2.5,3] (3,3.5] (3.5,4] #> H       0       0       0       0       0       0       0       0 #> N       0       0       0       0       0       0       0       0 #> O       0       0       0       0       0       0       0       0 #>  #> , , (0.5,1] #>  #>   [0,0.5] (0.5,1] (1,1.5] (1.5,2] (2,2.5] (2.5,3] (3,3.5] (3.5,4] #> H       0       0       0       0       0       0       0       0 #> N       0       0       0       0       0       0       0       0 #> O       0       2       0       0       0       0       0       0 #>  #> , , (1,1.5] #>  #>   [0,0.5] (0.5,1] (1,1.5] (1.5,2] (2,2.5] (2.5,3] (3,3.5] (3.5,4] #> H       0       0       0       0       0       0       0       3 #> N       0       0       0       0       0       0       0       0 #> O       0       0       0       0       0       0       0       0 #>  #> , , (1.5,2] #>  #>   [0,0.5] (0.5,1] (1,1.5] (1.5,2] (2,2.5] (2.5,3] (3,3.5] (3.5,4] #> H       0       0       0       0       0       0       0       0 #> N       0       0       0       0       0       0       0       0 #> O       0       0       0       0       0       0       0       0 #>   ## Build cummulative abundance surface Y <- CAS(X)  Y[[2]] #> , , [0,0.5] #>  #>   [0,0.5] (0.5,1] (1,1.5] (1.5,2] (2,2.5] (2.5,3] (3,3.5] (3.5,4] #> H       3       3       3       3       3       3       3       3 #> N       0       0       0       0       0       0       0       0 #> O       2       2       0       0       0       0       0       0 #>  #> , , (0.5,1] #>  #>   [0,0.5] (0.5,1] (1,1.5] (1.5,2] (2,2.5] (2.5,3] (3,3.5] (3.5,4] #> H       3       3       3       3       3       3       3       3 #> N       0       0       0       0       0       0       0       0 #> O       2       2       0       0       0       0       0       0 #>  #> , , (1,1.5] #>  #>   [0,0.5] (0.5,1] (1,1.5] (1.5,2] (2,2.5] (2.5,3] (3,3.5] (3.5,4] #> H       3       3       3       3       3       3       3       3 #> N       0       0       0       0       0       0       0       0 #> O       0       0       0       0       0       0       0       0 #>  #> , , (1.5,2] #>  #>   [0,0.5] (0.5,1] (1,1.5] (1.5,2] (2,2.5] (2.5,3] (3,3.5] (3.5,4] #> H       0       0       0       0       0       0       0       0 #> N       0       0       0       0       0       0       0       0 #> O       0       0       0       0       0       0       0       0 #>   ##  Extracts the first and second marginal (i.e. CAP on heights or diameters respectively) Y.M1 <- CASmargin(Y, margin = 1) Y.M1[[2]] #>   [0,0.5] (0.5,1] (1,1.5] (1.5,2] (2,2.5] (2.5,3] (3,3.5] (3.5,4] #> H       3       3       3       3       3       3       3       3 #> N       0       0       0       0       0       0       0       0 #> O       2       2       0       0       0       0       0       0  Y.M2 <- CASmargin(Y, margin = 2) Y.M2[[2]] #>   [0,0.5] (0.5,1] (1,1.5] (1.5,2] #> H       3       3       3       0 #> N       0       0       0       0 #> O       2       2       0       0  ##  For comparison we calculate the same profiles using the stratifyvegdata and CAP functions Y1 <- CAP(stratifyvegdata(treedata, sizes1=heights, plotColumn=\"plotID\",                          speciesColumn=\"species\", size1Column=\"height\",                          counts=TRUE))                    Y1[[2]] #>   [0,0.5] (0.5,1] (1,1.5] (1.5,2] (2,2.5] (2.5,3] (3,3.5] (3.5,4] #> H       3       3       3       3       3       3       3       3 #> N       0       0       0       0       0       0       0       0 #> O       2       2       0       0       0       0       0       0 Y2 <- CAP(stratifyvegdata(treedata, sizes1=diameters, plotColumn=\"plotID\",                          speciesColumn=\"species\", size1Column=\"diam\",                          counts=TRUE))                    Y2[[2]] #>   [0,0.5] (0.5,1] (1,1.5] (1.5,2] #> H       3       3       3       0 #> N       0       0       0       0 #> O       2       2       0       0  ##  Compare Y.M1[[2]] with Y1[[2]] and Y.M2[[2]] with Y2[[2]]"},{"path":"https://emf-creaf.github.io/vegclust/reference/as.memb.html","id":null,"dir":"Reference","previous_headings":"","what":"Turns into membership matrix — as.memb","title":"Turns into membership matrix — as.memb","text":"Attempts turn cluster vector argument membership matrix","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/as.memb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Turns into membership matrix — as.memb","text":"","code":"as.memb(cluster)"},{"path":"https://emf-creaf.github.io/vegclust/reference/as.memb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Turns into membership matrix — as.memb","text":"cluster vector indicating hard membership object x set groups. Can contain NA values.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/as.memb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Turns into membership matrix — as.memb","text":"matrix many rows length cluster many columns different cluster levels. NA values zero membership clusters","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/as.memb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Turns into membership matrix — as.memb","text":"Miquel De Cáceres, CREAF.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/as.memb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Turns into membership matrix — as.memb","text":"","code":"as.memb(factor(c(1,2,NA))) #>      1 2 #> [1,] 1 0 #> [2,] 0 1 #> [3,] 0 0"},{"path":"https://emf-creaf.github.io/vegclust/reference/as.vegclust.html","id":null,"dir":"Reference","previous_headings":"","what":"Turns into vegclust objects — as.vegclust","title":"Turns into vegclust objects — as.vegclust","text":"Attempts turn arguments vegclust object","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/as.vegclust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Turns into vegclust objects — as.vegclust","text":"","code":"as.vegclust(x, y, method = \"KM\", m = 1, dnoise = NULL, eta = NULL)"},{"path":"https://emf-creaf.github.io/vegclust/reference/as.vegclust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Turns into vegclust objects — as.vegclust","text":"x site--species data matrix (raw mode), site--site distance matrix (distance mode). y vector indicating cluster object x belongs . Alternatively, fuzzy/hard site--group matrix membership values. method clustering model y obtained (normally \"KM\"). Current accepted models : \"KM\": K-means hard c-means (MacQueen 1967) \"KMdd\": Hard c-medoids (Krishnapuram et al. 1999) \"FCM\": Fuzzy c-means (Bezdek 1981) \"FCMdd\": Fuzzy c-medoids (Krishnapuram et al. 1999) \"NC\": Noise clustering (Dave Krishnapuram 1997) \"NCdd\": Noise clustering medoids \"HNC\": Hard noise clustering \"HNCdd\": Hard noise clustering medoids \"PCM\": Possibilistic c-means (Krishnapuram Keller 1993) \"PCMdd\": Possibilistic c-medoids m fuzziness exponent used, relevant fuzzy models (FCM, FCMdd, NC, NCdd, PCM PCMdd). dnoise distance noise cluster, relevant noise clustering models (NC, HNC, NCdd HNCdd). eta vector reference distances, relevant possibilistic models (PCM PCMdd).","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/as.vegclust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Turns into vegclust objects — as.vegclust","text":"object class vegclust.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/as.vegclust.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Turns into vegclust objects — as.vegclust","text":"function used generate vegclust objects can used vegclass classify new data. input classification hard (.e. yes/membership), cluster centers calculated multivariate means, method assigning new data assumed k-means (\"KM\"), .e. plots assigned nearest cluster center. community data given site--species data matrix cluster centroids added mobileCenters vegclust object. Centroids computed community data given site--site dissimilarity matrix. Moreover, current implementation allow y membership matrix x distance matrix.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/as.vegclust.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Turns into vegclust objects — as.vegclust","text":"Miquel De Cáceres, CREAF.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/as.vegclust.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Turns into vegclust objects — as.vegclust","text":"","code":"## Loads data   data(wetland)  ## This equals the chord transformation  wetland.chord <- as.data.frame(sweep(as.matrix(wetland), 1,                                       sqrt(rowSums(as.matrix(wetland)^2)), \"/\"))  ## Splits wetland data into two matrices of 30x27 and 11x22 wetland.30 <- wetland.chord[1:30,] wetland.30 <- wetland.30[,colSums(wetland.30)>0] dim(wetland.30) #> [1] 30 27 wetland.11 <- wetland.chord[31:41,] wetland.11 <- wetland.11[,colSums(wetland.11)>0]  dim(wetland.11) #> [1] 11 22  ## Performs a K-means clustering of the data set with 30 sites wetland.km <- kmeans(wetland.30, centers=3, nstart=10)  ## Transforms the 'external' classification of 30 sites into a 'vegclust' object wetland.30.vc <- as.vegclust(wetland.30, wetland.km$cluster)  ## Assigns the second set of sites according to the (k-means) membership rule  ## That is, sites are assigned to the cluster whose cluster centroids is nearest. wetland.11.km <- vegclass(wetland.30.vc, wetland.11)  ## A similar 'vegclust' object is obtained when using the distance mode... wetland.d.vc <- as.vegclust(dist(wetland.30), wetland.km$cluster)  ## which can be also used to produce the assignment of the second set of objects wetland.d.11 <- as.data.frame(as.matrix(dist(wetland.chord)))[31:41,1:30] wetland.d.11.km <- vegclass(wetland.d.vc,wetland.d.11)"},{"path":"https://emf-creaf.github.io/vegclust/reference/clustcentroid.html","id":null,"dir":"Reference","previous_headings":"","what":"Cluster centers of a classification — clustcentroid","title":"Cluster centers of a classification — clustcentroid","text":"Function clustcentroid calculates centroid (multivariate average) coordinates classification. Function clustmedoid determines medoid (object whose average dissimilarity objects minimal) cluster classification.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/clustcentroid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cluster centers of a classification — clustcentroid","text":"","code":"clustcentroid(x, y, m = 1)  clustmedoid(x, y, m = 1)"},{"path":"https://emf-creaf.github.io/vegclust/reference/clustcentroid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cluster centers of a classification — clustcentroid","text":"x Community data, site--species data frame. function clustmedoid, x can alternatively object class dist (otherwise, dissimilarity measure assumed Euclidean distance). y can () vector indicating cluster object x belongs ; (b) fuzzy/hard site--group matrix membership values; (c) object class vegclust vegclass m Fuzziness exponent, effective y fuzzy membership matrix.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/clustcentroid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cluster centers of a classification — clustcentroid","text":"Function clustcentroid returns group--species matrix containing species average abundance values (.e. coordinates cluster centroid). Function clustmedoid returns vector indices (medoids).","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/clustcentroid.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cluster centers of a classification — clustcentroid","text":"order assign new plot record data predefined set classes, one use functions .vegclust vegclass instead.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/clustcentroid.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cluster centers of a classification — clustcentroid","text":"Miquel De Cáceres, CREAF.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/clustcentroid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cluster centers of a classification — clustcentroid","text":"","code":"## Loads stats library(stats)  ## Loads data data(wetland)  ## This equals the chord transformation  ## (see also \\code{\\link{decostand}} in package 'vegan') wetland.chord <- as.data.frame(sweep(as.matrix(wetland), 1,                                      sqrt(rowSums(as.matrix(wetland)^2)), \"/\"))  ## Performs a K-means clustering wetland.km <- kmeans(wetland.chord, centers=3, nstart=10)  ## Gets the coordinates corresponding to the centroids of KM clusters clustcentroid(wetland.chord, y=wetland.km$cluster) #>       Abefic     Merhed     Alyvag     Pancam     Abemos     Melcor     Ludoct #> 1 0.00000000 0.00000000 0.04696958 0.07606533 0.01558699 0.15317754 0.00000000 #> 2 0.00000000 0.00000000 0.00000000 0.02725749 0.00000000 0.06157316 0.00000000 #> 3 0.01825742 0.06770211 0.00000000 0.35635911 0.01458650 0.27504998 0.01889822 #>       Eupvac     Echpas     Passcr       Poa2     Carhal     Dendio     Casobt #> 1 0.05023873 0.06646064 0.00000000 0.01041893 0.06911470 0.00000000 0.00000000 #> 2 0.03879374 0.04762643 0.00000000 0.00000000 0.03679444 0.01572125 0.01631471 #> 3 0.20498936 0.10174214 0.02581989 0.00000000 0.00000000 0.00000000 0.00000000 #>       Aesind     Cyprot     Ipocop     Cynarc     Walind    Sessp.     Phynod #> 1 0.07475403 0.08126971 0.01262691 0.01262691 0.06377158 0.1041481 0.71534308 #> 2 0.00000000 0.00000000 0.00000000 0.00000000 0.06827998 0.1437923 0.00000000 #> 3 0.01889822 0.17597447 0.03974967 0.43238581 0.07754611 0.1569788 0.06361634 #>      Echell     Helind     Ipoaqu    Orysp.    Elesp.     Psespi   Ludads #> 1 0.1191200 0.17218890 0.04775048 0.1720463 0.1377765 0.02691262 0.000000 #> 2 0.0491431 0.12531919 0.05532759 0.6491987 0.1535492 0.19245622 0.204177 #> 3 0.1120500 0.01889822 0.03657589 0.0400000 0.0000000 0.00000000 0.000000 #>       Polatt       Poa1     Helcri     Physp.     Goopur #> 1 0.00000000 0.01282895 0.01282895 0.00000000 0.00000000 #> 2 0.09678166 0.00000000 0.00000000 0.01153624 0.01153624 #> 3 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000  ## Gets the object indices corresponding to the medoids of KM clusters clustmedoid(wetland.chord, y=wetland.km$cluster) #> 12  2 24  #> 23 11 34"},{"path":"https://emf-creaf.github.io/vegclust/reference/clustconst.html","id":null,"dir":"Reference","previous_headings":"","what":"Constancy table of a classification — clustconst","title":"Constancy table of a classification — clustconst","text":"Allows studying constancy table (.e. frequency species class) classification represented form membership data matrix.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/clustconst.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constancy table of a classification — clustconst","text":"","code":"clustconst(x, memb)  # S3 method for class 'clustconst' summary(   object,   mode = \"all\",   name = NULL,   sort = TRUE,   minconst = 0.5,   digits = 3,   ... )"},{"path":"https://emf-creaf.github.io/vegclust/reference/clustconst.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constancy table of a classification — clustconst","text":"x Community data, site species data frame. memb site--group matrix indicating (hard fuzzy) membership object x set groups. object object class 'clustconst'. mode Use mode=\"\" print constancy table, mode=\"cluster\" print constancy values one cluster, mode=\"species\", print constancy values one species. name string name cluster (mode=\"cluster\"), name species (mode=\"species\"). sort flag indicate whether constancy table sorted descending order. minconst threshold used limit values shown. digits number digits rounding. ... Additional parameters summary (actually used).","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/clustconst.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constancy table of a classification — clustconst","text":"Function clustconst returns object type 'clustconst', fact data frame constancy value species (rows) cluster (column).","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/clustconst.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Constancy table of a classification — clustconst","text":"constancy value species vegetation unit relative frequency occurrence species plot records belong unit. case fuzzy vegetation unit constancy value sum memberships sites contain species divided sum memberships sites. Use 'summary' function obtain information : (1) species frequent given vegetation unit; (2) vegetation units higher frequencies given target species. Additionally, 'summary' function can sort constancy table mode=\"\" sort=TRUE indicated.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/clustconst.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Constancy table of a classification — clustconst","text":"Miquel De Cáceres, CREAF","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/clustconst.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constancy table of a classification — clustconst","text":"","code":"## Loads stats library(stats)    ## Loads data   data(wetland)  ## This equals the chord transformation  ## (see also \\code{\\link{decostand}} in package 'vegan') wetland.chord <- as.data.frame(sweep(as.matrix(wetland), 1,                                       sqrt(rowSums(as.matrix(wetland)^2)), \"/\"))  ## Performs a K-means clustering wetland.km <- kmeans(wetland.chord, centers=3, nstart=10)  ## Gets constancy table of KM (i.e. hard) clusters c <- clustconst(wetland.chord, memb=as.memb(wetland.km$cluster))  ## Prints constancy values ordered and store the result in d d <- summary(c, mode=\"all\") #> ------------ 3 ------------- #>            3     1     2 #> Phynod 1.000 0.200 0.000 #> Helind 0.786 0.100 0.471 #> Elesp. 0.643 0.000 0.471 #> ------------ 1 ------------- #>            3     1     2 #> Melcor 0.786 1.000 0.294 #> Eupvac 0.286 0.900 0.118 #> Pancam 0.429 0.800 0.118 #> Sessp. 0.429 0.700 0.412 #> Cynarc 0.071 0.600 0.000 #> ------------ 2 ------------- #>            3     1     2 #> Orysp. 0.429 0.100 1.000 #> Ludads 0.000 0.000 0.824  ## Prints the most frequent species in the first cluster summary(c, mode=\"cluster\", name=names(c)[1]) #> Melcor 1.000  #> Eupvac 0.900  #> Pancam 0.800  #> Sessp. 0.700  #> Cynarc 0.600"},{"path":"https://emf-creaf.github.io/vegclust/reference/clustvar.html","id":null,"dir":"Reference","previous_headings":"","what":"Cluster variance — clustvar","title":"Cluster variance — clustvar","text":"Computes variation community composition (.e. beta diversity) found within sites set hard fuzzy clusters.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/clustvar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cluster variance — clustvar","text":"","code":"clustvar(x, cluster = NULL, defuzzify = FALSE, ...)"},{"path":"https://emf-creaf.github.io/vegclust/reference/clustvar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cluster variance — clustvar","text":"x Community data. Either site--species matrix site--site matrix compositional distances sites  (.e., object class dist). Alternatively, can object class vegclust vegclass, case unnecessary provide cluster. cluster vector indicating hard membership object x set groups. defuzzify flag indicating whether fuzzy memberships defuzzified (see function defuzzify). applies case object class vegclust vegclass supplied x. ... Additional parameters function defuzzify.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/clustvar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cluster variance — clustvar","text":"double value (one cluster) vector values, one per cluster.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/clustvar.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cluster variance — clustvar","text":"function can used two ways: x data matrix (site species distances among sites) cluster null, function assumes single cluster points x. cluster provided, function computes cluster variance (hard) group computation implies setting centroid group. Cluster variance defined average squared distance centroid. x object class vegclust vegclass, function uses information contained (distances cluster centers, memberships exponent fuzziness) order compute cluster variances. Cluster centers need recomputed, distances cluster centers used directly. centroid-based cluster models (KM, FCM, NC, HNC PCM) variance defined average squared distance centroid. medoid-based cluster models (KMdd, FCMdd, NCdd, HNCdd PCMdd) variance defined average distance medoid. variance mobile fixed clusters returned. Additionally, membership matrices may defuzzified defuzzify=TRUE.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/clustvar.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cluster variance — clustvar","text":"Miquel De Cáceres, CREAF","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/clustvar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cluster variance — clustvar","text":"","code":"## Loads data   data(wetland)  ## This equals the chord transformation  ## (see also \\code{\\link{decostand}} in package 'vegan') wetland.chord <- as.data.frame(sweep(as.matrix(wetland), 1,                                       sqrt(rowSums(as.matrix(wetland)^2)), \"/\"))  ## Create noise clustering with 3 clusters. Perform 10 starts from random seeds  ## and keep the best solution wetland.nc <- vegclust(wetland.chord, mobileCenters=3, m = 1.2, dnoise=0.75,                         method=\"NC\", nstart=10)  ## Gets cluster variance of fuzzy clusters clustvar(wetland.nc) #>        M1        M2        M3  #> 0.2924091 0.2612891 0.2556575   ## Gets cluster variance of fuzzy clusters after defuzzification clustvar(wetland.nc, defuzzify=TRUE) #>        M1        M2        M3  #> 0.2875054 0.2478222 0.2379082   ## Similar to the previous, this gets cluster variance of defuzzified (i.e. hard) clusters clustvar(wetland.chord, cluster=defuzzify(wetland.nc)$cluster) #>        M1        M2        M3         N  #> 0.2861120 0.2474883 0.2372548 0.7175326   ## Gets cluster variance of K-means (i.e. hard) clusters clustvar(wetland.chord, cluster=kmeans(wetland.chord, centers=3, nstart=10)$cluster) #>         1         2         3  #> 0.3215797 0.4684155 0.4099091"},{"path":"https://emf-creaf.github.io/vegclust/reference/concordance.html","id":null,"dir":"Reference","previous_headings":"","what":"Concordance between two classifications — concordance","title":"Concordance between two classifications — concordance","text":"Computes index compare two classifications.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/concordance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Concordance between two classifications — concordance","text":"","code":"concordance(x, y, method = \"adjustedRand\", ...)"},{"path":"https://emf-creaf.github.io/vegclust/reference/concordance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Concordance between two classifications — concordance","text":"x, y Classification vector membership matrix. Alternatively, objects type vegclust vegclass. method string vector indicate desired indices (see details). ... Additional parameters function defuzzify, called x y type matrix, vegclust vegclass.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/concordance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Concordance between two classifications — concordance","text":"numeric vector desired index values.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/concordance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Concordance between two classifications — concordance","text":"Several indices comparison partitions available: method=\"Rand\": Rand (1971) index. method=\"adjustedRand\": Rand index adjusted random effects (Hubert & Arabie 1985). method=\"Wallace\": Wallace (1983) index (asymmetrical comparisons). index (adjusted version) useful quantify much x nested y. method=\"adjustedWallace\": Wallace index adjusted random effects (Pinto et al. 2008).","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/concordance.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Concordance between two classifications — concordance","text":"Hubert, L. & Arabie, P. (1985). Comparing partitions. Journal Classification, 2, 193–218. Pinto, F.R., Melo-Cristino, J. & Ramirez, M. (2008). confidence interval wallace coefficient concordance application microbial typing methods. PLoS ONE, 3. Rand, W.M. (1971). Objective Criteria Evaluation Clustering Methods. Journal American Statistical Association, 66, 846–850. Wallace, D.L. (1983). method comparing two hierarchical clusterings: Comment. Journal American Statistical Association, 78, 569–576.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/concordance.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Concordance between two classifications — concordance","text":"Miquel De Cáceres, CREAF","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/conformveg.html","id":null,"dir":"Reference","previous_headings":"","what":"Conform two community data tables — conformveg","title":"Conform two community data tables — conformveg","text":"Conforms two community data tables set columns (species)","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/conformveg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conform two community data tables — conformveg","text":"","code":"conformveg(x, y, fillvalue = 0, verbose = FALSE)"},{"path":"https://emf-creaf.github.io/vegclust/reference/conformveg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conform two community data tables — conformveg","text":"x Community data, site--species matrix. y Community data, site--species matrix. fillvalue value used fill new entries inflated matrices. verbose Displays information number species shared x y, well number species one data tables .","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/conformveg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conform two community data tables — conformveg","text":"list two inflated matrices x y.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/conformveg.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Conform two community data tables — conformveg","text":"function adds x many new columns columns y x. done y, two tables set columns returned.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/conformveg.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Conform two community data tables — conformveg","text":"Miquel De Cáceres, CREAF.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/conformveg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conform two community data tables — conformveg","text":"","code":"## Loads data (38 columns and 33 species) data(wetland) dim(wetland) #> [1] 41 33  ## Splits wetland data into two matrices of 30x27 and 11x22 wetland.30 <- wetland[1:30,] wetland.30 <- wetland.30[,colSums(wetland.30)>0] dim(wetland.30) #> [1] 30 27 wetland.11 <- wetland[31:41,] wetland.11 <- wetland.11[,colSums(wetland.11)>0]  dim(wetland.11) #> [1] 11 22  ## Conforms the two matrices so they can eventually be merged wetland.cf <- conformveg(wetland.30, wetland.11) dim(wetland.cf$x) #> [1] 30 33 dim(wetland.cf$y) #> [1] 11 33 names(wetland.cf$x)==names(wetland.cf$y) #>  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [31] TRUE TRUE TRUE"},{"path":"https://emf-creaf.github.io/vegclust/reference/crossmemb.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-table of two fuzzy classifications — crossmemb","title":"Cross-table of two fuzzy classifications — crossmemb","text":"Calculates cross-tabulated matrix relating two fuzzy membership matrices","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/crossmemb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-table of two fuzzy classifications — crossmemb","text":"","code":"crossmemb(x, y, relativize = TRUE)"},{"path":"https://emf-creaf.github.io/vegclust/reference/crossmemb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-table of two fuzzy classifications — crossmemb","text":"x site--group fuzzy membership matrix. Alternatively, object class 'vegclust' 'vegclass'. y site--group fuzzy membership matrix. Alternatively, object class 'vegclust' 'vegclass'. relativize TRUE expresses cross-tabulated values proportions cluster size x.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/crossmemb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-table of two fuzzy classifications — crossmemb","text":"cross-tabulated matrix comparing two classifications. general, cell's value (fuzzy) number objects x assigned cluster corresponding row y assigned cluster corresponding column. relativize=TRUE values row divided (fuzzy) size corresponding cluster x.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/crossmemb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cross-table of two fuzzy classifications — crossmemb","text":"Miquel De Cáceres, CREAF.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/crossmemb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-table of two fuzzy classifications — crossmemb","text":"","code":"## Loads data   data(wetland)    ## This equals the chord transformation  wetland.chord <- as.data.frame(sweep(as.matrix(wetland), 1,                                 sqrt(rowSums(as.matrix(wetland)^2)), \"/\"))  ## Create clustering with 3 clusters. Perform 10 starts from random seeds  ## and keep the best solution. Try both FCM and NC methods: wetland.fcm <- vegclust(wetland.chord, mobileCenters=3, m = 1.2, method=\"FCM\", nstart=10) wetland.nc <- vegclust(wetland.chord, mobileCenters=3, m = 1.2, dnoise=0.75, method=\"NC\",                        nstart=10)  ## Compare the results crossmemb(wetland.fcm, wetland.nc, relativize=FALSE) #>            M1         M2         M3        N #> M1  0.1239886  0.1392292 5.88716190 4.413414 #> M2 11.0737653  0.3649210 0.09099900 1.922028 #> M3  0.2182418 11.9909029 0.04988801 4.725461"},{"path":"https://emf-creaf.github.io/vegclust/reference/defuzzify.html","id":null,"dir":"Reference","previous_headings":"","what":"Defuzzifies a fuzzy partition — defuzzify","title":"Defuzzifies a fuzzy partition — defuzzify","text":"Transforms fuzzy classification crisp (hard) classification.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/defuzzify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Defuzzifies a fuzzy partition — defuzzify","text":"","code":"defuzzify(object, method = \"max\", alpha = 0.5, na.rm = FALSE)"},{"path":"https://emf-creaf.github.io/vegclust/reference/defuzzify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Defuzzifies a fuzzy partition — defuzzify","text":"object site--group fuzzy membership matrix. Alternatively, object class 'vegclust' 'vegclass'. method Either \"max\" choose maximum membership value across clusters, \"cut\" alpha-cut. alpha Threshold alpha-cut, bounded 0 1. na.rm TRUE removes objects belong cluster using method=\"cut\".","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/defuzzify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Defuzzifies a fuzzy partition — defuzzify","text":"list following items: memb: data frame hard membership partition. cluster: vector (factor) name cluster object.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/defuzzify.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Defuzzifies a fuzzy partition — defuzzify","text":"Alpha-cut means memberships lower alpha transformed 0 memberships higher alpha transformed 1. means alpha values low (.e. close 0), object may belong one group defuzzification. generate concatenation cluster names output cluster vector row sum one memb matrix). Similarly, alpha high (.e. close 1) objects may left unclassified. get NA cluster vector zero row memb matrix.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/defuzzify.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Defuzzifies a fuzzy partition — defuzzify","text":"Davé, R. N. R. Krishnapuram (1997) Robust clustering methods: unified view. IEEE Transactions Fuzzy Systems 5, 270-293.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/defuzzify.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Defuzzifies a fuzzy partition — defuzzify","text":"Miquel De Cáceres, CREAF.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/defuzzify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Defuzzifies a fuzzy partition — defuzzify","text":"","code":"## Loads data   data(wetland)  ## This equals the chord transformation  wetland.chord <- as.data.frame(sweep(as.matrix(wetland), 1,                                       sqrt(rowSums(as.matrix(wetland)^2)), \"/\"))  ## Create noise clustering with 3 clusters. Perform 10 starts from random seeds  ## and keep the best solution wetland.nc <- vegclust(wetland.chord, mobileCenters=3, m = 1.2, dnoise=0.75,                         method=\"NC\", nstart=10)  ## Defuzzification using an alpha-cut (alpha=0.5) wetland.nc.df <- defuzzify(wetland.nc$memb, method=\"cut\")  ## Cluster vector, with 'N' for objects that are unclassified,  ## and 'NA' for objects that are intermediate print(wetland.nc.df$cluster) #>    5    8   13    4   17    3    9   21   16   14    2   15    1    7   10   40  #> \"M1\" \"M1\" \"M1\" \"M1\" \"M1\"  \"N\"  \"N\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\"  \"N\"  \"N\" \"M3\"  #>   23   25   22   20    6   18   12   39   19   11   30   34   28   31   26   29  #> \"M3\" \"M3\"   NA \"M3\" \"M3\" \"M3\" \"M3\" \"M3\" \"M3\" \"M3\"  \"N\" \"M2\"  \"N\" \"M2\"  \"N\"  \"N\"  #>   33   24   36   37   41   27   32   35   38  #> \"M3\" \"M2\" \"M2\" \"M2\" \"M2\"  \"N\"  \"N\"  \"N\" \"M1\"   ## Hard membership matrix (site 22 does not get any cluster assigned) print(wetland.nc.df$memb) #>    M1 M2 M3 N #> 5   1  0  0 0 #> 8   1  0  0 0 #> 13  1  0  0 0 #> 4   1  0  0 0 #> 17  1  0  0 0 #> 3   0  0  0 1 #> 9   0  0  0 1 #> 21  1  0  0 0 #> 16  1  0  0 0 #> 14  1  0  0 0 #> 2   1  0  0 0 #> 15  1  0  0 0 #> 1   1  0  0 0 #> 7   0  0  0 1 #> 10  0  0  0 1 #> 40  0  0  1 0 #> 23  0  0  1 0 #> 25  0  0  1 0 #> 22  0  0  0 0 #> 20  0  0  1 0 #> 6   0  0  1 0 #> 18  0  0  1 0 #> 12  0  0  1 0 #> 39  0  0  1 0 #> 19  0  0  1 0 #> 11  0  0  1 0 #> 30  0  0  0 1 #> 34  0  1  0 0 #> 28  0  0  0 1 #> 31  0  1  0 0 #> 26  0  0  0 1 #> 29  0  0  0 1 #> 33  0  0  1 0 #> 24  0  1  0 0 #> 36  0  1  0 0 #> 37  0  1  0 0 #> 41  0  1  0 0 #> 27  0  0  0 1 #> 32  0  0  0 1 #> 35  0  0  0 1 #> 38  1  0  0 0"},{"path":"https://emf-creaf.github.io/vegclust/reference/hcr.html","id":null,"dir":"Reference","previous_headings":"","what":"Heterogeneity-constrained random resampling (HCR) — hcr","title":"Heterogeneity-constrained random resampling (HCR) — hcr","text":"Returns set indices original data set maximizes mean minimizes variance distances pairs plot records.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/hcr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Heterogeneity-constrained random resampling (HCR) — hcr","text":"","code":"hcr(d, nout, nsampl = 1000)"},{"path":"https://emf-creaf.github.io/vegclust/reference/hcr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Heterogeneity-constrained random resampling (HCR) — hcr","text":"d object class dist containing distance values pairs sites (plot records). nout number sites (plot records) chosen among available d. nsampl number resampling trials compared.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/hcr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Heterogeneity-constrained random resampling (HCR) — hcr","text":"Returns vector containing indices selected sites (plot records) used sub-setting original table.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/hcr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Heterogeneity-constrained random resampling (HCR) — hcr","text":"Many subsets input data selected randomly. subsets sorted decreasing mean dissimilarity pairs plot records, sorted increasing variance dissimilarities. Ranks sortings summed subset, subset lowest summed rank considered representative.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/hcr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Heterogeneity-constrained random resampling (HCR) — hcr","text":"Lengyel, ., Chytry, M., Tichy, L. (2011) Heterogeneity-constrained random resampling phytosociological databases. Journal Vegetation Science 22: 175-183.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/hcr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Heterogeneity-constrained random resampling (HCR) — hcr","text":"Miquel De Cáceres, CREAF","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/hcr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Heterogeneity-constrained random resampling (HCR) — hcr","text":"","code":"## Loads data (38 columns and 33 species) data(wetland) dim(wetland) #> [1] 41 33  ## Constructs the chord distance matrix wetland.chord <-dist(as.data.frame(sweep(as.matrix(wetland), 1,                                           sqrt(rowSums(as.matrix(wetland)^2)), \"/\")))  ## Performs HCR resampling. Returns indices of objects sel <- hcr(wetland.chord, nout=20, nsampl=1000)  ## Prints the names of the plot records print(row.names(wetland)[sel]) #>  [1] \"8\"  \"17\" \"3\"  \"9\"  \"16\" \"2\"  \"1\"  \"10\" \"22\" \"20\" \"39\" \"11\" \"30\" \"28\" \"31\" #> [16] \"26\" \"24\" \"36\" \"32\" \"35\"  ## Subset the original distance matrix sel.chord <- as.dist(as.matrix(wetland.chord)[sel,sel])"},{"path":"https://emf-creaf.github.io/vegclust/reference/hier.vegclust.html","id":null,"dir":"Reference","previous_headings":"","what":"Clustering with several number of clusters — hier.vegclust","title":"Clustering with several number of clusters — hier.vegclust","text":"Performs several runs function 'vegclust' ('vegclustdist') community data matrix (distance matrix) using different number clusters","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/hier.vegclust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clustering with several number of clusters — hier.vegclust","text":"","code":"hier.vegclust(   x,   hclust,   cmin = 2,   cmax = 20,   min.size = NULL,   verbose = TRUE,   ... )  random.vegclust(   x,   cmin = 2,   cmax = 20,   nstart = 10,   min.size = NULL,   verbose = TRUE,   ... )  hier.vegclustdist(   x,   hclust,   cmin = 2,   cmax = 20,   min.size = NULL,   verbose = TRUE,   ... )  random.vegclustdist(   x,   cmin = 2,   cmax = 20,   nstart = 10,   min.size = NULL,   verbose = TRUE,   ... )"},{"path":"https://emf-creaf.github.io/vegclust/reference/hier.vegclust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clustering with several number of clusters — hier.vegclust","text":"x hier.vegclust random.vegclust, site (rows) species (columns) matrix data frame. hier.vegclustdist random.vegclustdist, square distance matrix. hclust hierarchical clustering represented object type hclust. cmin Number minimum mobile clusters. cmax Number maximum mobile clusters. min.size min.size != NULL, specifies minimum size clusters. clusters smaller, algorithm return solutions corresponding lower numbers clusters. verbose Flag used print number clusters currently running. ... Additional parameters function vegclust vegclustdist. nstart number indicating many random trials performed number groups","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/hier.vegclust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clustering with several number of clusters — hier.vegclust","text":"Returns object type 'mvegclust' (multiple vegclust), contains list vector objects type vegclust.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/hier.vegclust.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Clustering with several number of clusters — hier.vegclust","text":"Function hier.vegclust takes starting cluster configurations cuts dendrogram given object hclust. Function random.vegclust chooses random objects cluster centroids number clusters performs nstart trials. Functions hier.vegclustdist random.vegclustdist analogous hier.vegclust random.vegclust accept distance matrices input.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/hier.vegclust.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Clustering with several number of clusters — hier.vegclust","text":"Miquel De Cáceres, CREAF","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/hier.vegclust.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clustering with several number of clusters — hier.vegclust","text":"","code":"## Loads data   data(wetland)  ## This equals the chord transformation  wetland.chord <- as.data.frame(sweep(as.matrix(wetland), 1,                                      sqrt(rowSums(as.matrix(wetland)^2)), \"/\"))  ## Create noise clustering from hierarchical clustering at different number of clusters wetland.hc <- hclust(dist(wetland.chord),method=\"ward\")  #> The \"ward\" method has been renamed to \"ward.D\"; note new \"ward.D2\" wetland.nc1 <- hier.vegclust(wetland.chord, wetland.hc, cmin=2, cmax=5,                               m = 1.2, dnoise=0.75, method=\"NC\") #> PROCESSING 2 MOBILE CLUSTERS #> PROCESSING 3 MOBILE CLUSTERS #> PROCESSING 4 MOBILE CLUSTERS #> PROCESSING 5 MOBILE CLUSTERS  ## Create noise clustering from random seeds at different levels wetland.nc2 <- random.vegclust(wetland.chord, cmin=2, cmax=5, nstart=10,                                m = 1.2, dnoise=0.75, method=\"NC\") #> PROCESSING 2 MOBILE CLUSTERS #> PROCESSING 3 MOBILE CLUSTERS #> PROCESSING 4 MOBILE CLUSTERS #> PROCESSING 5 MOBILE CLUSTERS"},{"path":"https://emf-creaf.github.io/vegclust/reference/incr.vegclust.html","id":null,"dir":"Reference","previous_headings":"","what":"Noise clustering with increasing number of clusters — incr.vegclust","title":"Noise clustering with increasing number of clusters — incr.vegclust","text":"Performs several runs function 'vegclust' community data matrix using increasing number clusters conditions met.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/incr.vegclust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Noise clustering with increasing number of clusters — incr.vegclust","text":"","code":"incr.vegclust(   x,   method = \"NC\",   ini.fixed.centers = NULL,   min.size = 10,   max.var = NULL,   alpha = 0.5,   nstart = 100,   fix.previous = TRUE,   dnoise = 0.75,   m = 1,   ... )"},{"path":"https://emf-creaf.github.io/vegclust/reference/incr.vegclust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Noise clustering with increasing number of clusters — incr.vegclust","text":"x Community data table. site (rows) species (columns) matrix data frame. method clustering model. Current accepted models noise clustering family: \"NC\": Noise clustering (Dave Krishnapuram 1997) \"NCdd\": Noise clustering medoids \"HNC\": Hard noise clustering \"HNCdd\": Hard noise clustering medoids ini.fixed.centers coordinates initial fixed cluster centers. used fixedCenters calls vegclust. method=\"NCdd\" method=\"HNCdd\" ini.fixed.centers can specified vector indices medoids. min.size minimum size (cardinality) clusters. current k clusters enough members algorithm stop return solution k-1 clusters. max.var maximum variance allowed clusters (see function clustvar). specified, algorithm stop clusters time small large variance. max.var = NULL criterion used. alpha Criterion choose cluster seeds noise class. Specifically, object considered cluster seed membership noise class larger alpha. nstart number indicating many random trials performed number groups. random trial uses k-1 cluster centers plus coordinates current cluster seed initial solution vegclust. Thus, less cluster seed candidates nstart, runs conducted. fix.previous Flag used indicate cluster centers found determining k-1 clusters fixed determining k clusters. dnoise distance noise cluster. m fuzziness exponent. ... Additional parameters function vegclust.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/incr.vegclust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Noise clustering with increasing number of clusters — incr.vegclust","text":"Returns object class vegclust; NULL initial cluster contain enough members.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/incr.vegclust.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Noise clustering with increasing number of clusters — incr.vegclust","text":"Function hier.vegclust takes starting cluster configurations cuts dendrogram given object hclust. Function random.vegclust chooses random objects cluster centroids number clusters performs nstart trials.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/incr.vegclust.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Noise clustering with increasing number of clusters — incr.vegclust","text":"Davé, R. N. R. Krishnapuram (1997) Robust clustering methods: unified view. IEEE Transactions Fuzzy Systems 5, 270-293.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/incr.vegclust.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Noise clustering with increasing number of clusters — incr.vegclust","text":"Miquel De Cáceres, CREAF","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/incr.vegclust.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Noise clustering with increasing number of clusters — incr.vegclust","text":"","code":"## Loads data   data(wetland)  ## This equals the chord transformation  wetland.chord <- as.data.frame(sweep(as.matrix(wetland), 1,                                      sqrt(rowSums(as.matrix(wetland)^2)), \"/\"))  ## Call incremental noise clustering  wetland.nc <- incr.vegclust(wetland.chord, method=\"NC\", m = 1.2, dnoise=0.75,                              min.size=5) #> Vegclust with one new group...Number of remaining cluster seeds: 28 #> Vegclust with 2 new groups............................Number of remaining cluster seeds: 17 #> Vegclust with 3 new groups.................Number of remaining cluster seeds: 11 #> Vegclust with 4 new groups...........Number of remaining cluster seeds: 8 #> Some of the current clusters are too small. Returning vegclust with 3 new group(s).  ## Inspect cluster sizes print(wetland.nc$size) #>        M1        F2        F3  #>  6.021867 11.240696 12.704684"},{"path":"https://emf-creaf.github.io/vegclust/reference/interclustdist.html","id":null,"dir":"Reference","previous_headings":"","what":"Distance between pairs of cluster centroids — interclustdist","title":"Distance between pairs of cluster centroids — interclustdist","text":"Calculates distance pairs cluster centroids, given distance matrix cluster vector.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/interclustdist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distance between pairs of cluster centroids — interclustdist","text":"","code":"interclustdist(x, cluster)"},{"path":"https://emf-creaf.github.io/vegclust/reference/interclustdist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distance between pairs of cluster centroids — interclustdist","text":"x site--site data matrix object class dist containing distance values pairs sites (plot records). cluster vector indicating hard membership object x set groups. Can contain NA values.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/interclustdist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distance between pairs of cluster centroids — interclustdist","text":"object class dist containing distances cluster centers.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/interclustdist.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Distance between pairs of cluster centroids — interclustdist","text":"Miquel De Cáceres, CREAF","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/medreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Regeneration of Mediterranean vegetation data set — medreg","title":"Regeneration of Mediterranean vegetation data set — medreg","text":"stratified vegetation data set containing several plot records laid assess vegetation recovery three years wildfire. Collected 2012 Miquel De Caceres Albert Petit Horta de Sant Joan (Catalonia, Spain).","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/medreg.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Regeneration of Mediterranean vegetation data set — medreg","text":"object class stratifiedvegdata 96 elements (plots), consisting data.frame rows correspond species groups columns correspond vegetation strata. Abundance values percentage cover.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/plot.CAP.html","id":null,"dir":"Reference","previous_headings":"","what":"Draws cummulative abundance profiles — plot.CAP","title":"Draws cummulative abundance profiles — plot.CAP","text":"Create plots used inspect one cumulative abundance profiles.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/plot.CAP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draws cummulative abundance profiles — plot.CAP","text":"","code":"# S3 method for class 'CAP' plot(   x,   sizes = NULL,   species = NULL,   plots = NULL,   switchAxes = FALSE,   add = FALSE,   drawAxes = TRUE,   xlab = \"\",   ylab = \"\",   type = \"s\",   ... )  # S3 method for class 'stratifiedvegdata' plot(   x,   sizes = NULL,   species = NULL,   plots = NULL,   switchAxes = FALSE,   add = FALSE,   drawAxes = TRUE,   xlab = \"\",   ylab = \"\",   type = \"s\",   ... )"},{"path":"https://emf-creaf.github.io/vegclust/reference/plot.CAP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draws cummulative abundance profiles — plot.CAP","text":"x object returned function CAP object class stratifiedvegdata (see documentation function stratifyvegdata). sizes vector containing size values associated size class. NULL y-axis defined using size class order x. species vector strings indicating species whose profile drawn. NULL species plotted. plots vector indicating plot records whose profile drawn. Can character vector (plot names), numeric vector (plot indices) logical vector (TRUE/FALSE selection). NULL plot records plotted. switchAxes flag indicating whether ordinate abscissa axes interchanged. add flag indicating whether profiles drawn top current drawing area. add=FALSE new plot created. drawAxes flag indicating whether axes drawn. xlab String label x axis. ylab String label y axis. type Type plot drawn (\"p\" points, \"l\" lines, \"s\" steps, ...). ... Additional plotting parameters.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/plot.CAP.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Draws cummulative abundance profiles — plot.CAP","text":"De Cáceres, M., Legendre, P. & , F. (2013) Dissimilarity measurements size structure ecological communities. Methods Ecology Evolution 4: 1167-1177.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/plot.CAP.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Draws cummulative abundance profiles — plot.CAP","text":"Miquel De Cáceres, CREAF","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/plot.CAP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draws cummulative abundance profiles — plot.CAP","text":"","code":"## Load stratified data data(medreg)  ## Check that 'medreg' has correct class class(medreg) #> [1] \"stratifiedvegdata\" \"list\"               ## Create cumulative abundance profile (CAP) for each plot medreg.CAP <- CAP(medreg)  ## Draw the stratified data and profile corresponding to the third plot plot(medreg, plots=\"3\")  plot(medreg.CAP, plots=\"3\")   ## Look at the plot and CAP of the same plot medreg[[\"3\"]] #>                                1    2    3    4    5 6 7 #> Pine trees                   0.0 12.5  0.0  0.0  0.0 0 0 #> Quercus trees                0.0  0.0 12.5 12.5 12.5 0 0 #> Tall shrubs and small trees  0.0 25.0 62.5 25.0  0.0 0 0 #> Scrubs and small shrubs      0.0 50.0  0.0  0.0  0.0 0 0 #> Grass                       37.5  0.0  0.0  0.0  0.0 0 0 medreg.CAP[[\"3\"]] #>                                 1     2    3  4    5 6 7 #> Pine trees                   12.5  12.5  0.0  0  0.0 0 0 #> Quercus trees                37.5  37.5 37.5 25 12.5 0 0 #> Tall shrubs and small trees 112.5 112.5 87.5 25  0.0 0 0 #> Scrubs and small shrubs      50.0  50.0  0.0  0  0.0 0 0 #> Grass                        37.5   0.0  0.0  0  0.0 0 0"},{"path":"https://emf-creaf.github.io/vegclust/reference/plot.CAS.html","id":null,"dir":"Reference","previous_headings":"","what":"Draws a cummulative abundance surface — plot.CAS","title":"Draws a cummulative abundance surface — plot.CAS","text":"Create plots used inspect one cumulative abundance surfaces.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/plot.CAS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draws a cummulative abundance surface — plot.CAS","text":"","code":"# S3 method for class 'CAS' plot(   x,   plot = NULL,   species = NULL,   sizes1 = NULL,   sizes2 = NULL,   palette = colorRampPalette(c(\"light blue\", \"light green\", \"white\", \"yellow\", \"orange\",     \"red\")),   zlim = NULL,   ... )"},{"path":"https://emf-creaf.github.io/vegclust/reference/plot.CAS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draws a cummulative abundance surface — plot.CAS","text":"x object class CAS. plot string indicating plot record whose surface drawn. species string indicating species whose profile drawn. sizes1 vector containing size values associated primary size class. NULL x-axis defined using primary size class order x. sizes2 vector containing size values associated secondary size class. NULL y-axis defined using secondary size class order x. palette Color palette z values. zlim limits z-axis. ... Additional plotting parameters function persp.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/plot.CAS.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Draws a cummulative abundance surface — plot.CAS","text":"De Cáceres, M., Legendre, P. & , F. (2013) Dissimilarity measurements size structure ecological communities. Methods Ecology Evolution 4: 1167-1177.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/plot.CAS.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Draws a cummulative abundance surface — plot.CAS","text":"Miquel De Cáceres, CREAF","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/plot.CAS.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draws a cummulative abundance surface — plot.CAS","text":"","code":"## Create synthetic tree data pl <- rep(1,100) # All trees in the same plot sp <- ifelse(runif(100)>0.5,1,2) # Random species identity (species 1 or 2) h <- rgamma(100,10,2) # Heights (m) d <- rpois(100, lambda=h^2) # Diameters (cm) m <- data.frame(plot=pl,species=sp, height=h,diameter=d)  m$ba <- pi*(m$diameter/200)^2 print(head(m)) #>   plot species   height diameter           ba #> 1    1       2 7.252218       42 1.385442e-01 #> 2    1       2 4.919238       18 2.544690e-02 #> 3    1       1 1.479482        1 7.853982e-05 #> 4    1       2 4.264047       17 2.269801e-02 #> 5    1       1 7.549600       52 2.123717e-01 #> 6    1       2 7.166193       67 3.525652e-01  ## Size classes heights <- seq(0,4, by=.25)^2 # Quadratic classes diams <- seq(0,130, by=5) # Linear classes  ## Stratify tree data X <- stratifyvegdata(m, sizes1=heights, sizes2=diams,                       plotColumn = \"plot\", speciesColumn = \"species\",                       size1Column = \"height\", size2Column = \"diameter\",                       abundanceColumn = \"ba\")  ## Build cummulative abundance surface Y <- CAS(X)  ## Plot the surface of species '1' in plot '1' using heights and diameters plot(Y, species=1, sizes1=heights[-1], xlab=\"height (m)\",       ylab=\"diameter (cm)\", sizes2=diams[-1], zlab=\"Basal area (m2)\",      zlim = c(0,6), main=\"Species 1\")"},{"path":"https://emf-creaf.github.io/vegclust/reference/plot.mvegclust.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots clustering results — plot.mvegclust","title":"Plots clustering results — plot.mvegclust","text":"Create plots used study vegclust clustering results increasing number clusters","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/plot.mvegclust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots clustering results — plot.mvegclust","text":"","code":"# S3 method for class 'mvegclust' plot(   x,   type = \"hnc\",   excludeFixed = TRUE,   verbose = FALSE,   ylim = NULL,   xlab = NULL,   ylab = NULL,   maxvar = 0.6,   minsize = 20,   ... )"},{"path":"https://emf-creaf.github.io/vegclust/reference/plot.mvegclust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots clustering results — plot.mvegclust","text":"x object returned functions hier.vegclust random.vegclust. type string indicating type plot desired. Current accepted values \"hnc\",\"hmemb\",\"var\",\"hcs\" \"valid\". excludeFixed flag indicate whether clusters fixed centroids excluded plots. verbose flag print extra information. ylim vector limits y axis. xlab String label x axis. ylab String label y axis. maxvar Maximum cluster variance allowed type=\"valid\" plot. minsize Minimum cluster size allowed type=\"valid\" plot. ... Additional plotting parameters.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/plot.mvegclust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plots clustering results — plot.mvegclust","text":"Different information returned depending type plot chosen.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/plot.mvegclust.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plots clustering results — plot.mvegclust","text":"Miquel De Cáceres, CREAF","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/plot.mvegclust.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots clustering results — plot.mvegclust","text":"","code":"## Loads data   data(wetland)  ## This equals the chord transformation  wetland.chord <- as.data.frame(sweep(as.matrix(wetland), 1,                                       sqrt(rowSums(as.matrix(wetland)^2)), \"/\"))  ## Create noise clustering from hierarchical clustering at different number of clusters wetland.hc <- hclust(dist(wetland.chord),method=\"ward\")  #> The \"ward\" method has been renamed to \"ward.D\"; note new \"ward.D2\" wetland.nc <- hier.vegclust(wetland.chord, wetland.hc, cmin=2, cmax=5, m = 1.2,                              dnoise=0.75, method=\"NC\") #> PROCESSING 2 MOBILE CLUSTERS #> PROCESSING 3 MOBILE CLUSTERS #> PROCESSING 4 MOBILE CLUSTERS #> PROCESSING 5 MOBILE CLUSTERS  ## Plot changes in the number of objects falling into the noise cluster plot(wetland.nc, type=\"hnc\")   ## Plots the number of objects falling into \"true\" clusters,  ## the number of objects considered intermediate,  ## and the number of objects falling into the noise plot(wetland.nc, type=\"hmemb\")   ## Plot minimum, maximum and average cluster size plot(wetland.nc, type=\"hcs\")   ## Plot minimum, maximum and average cluster variance plot(wetland.nc, type=\"var\")   ## Plot number of groups with high variance, low membership or both plot(wetland.nc, type=\"valid\")"},{"path":"https://emf-creaf.github.io/vegclust/reference/relate.levels.html","id":null,"dir":"Reference","previous_headings":"","what":"Relates two clustering level results — relate.levels","title":"Relates two clustering level results — relate.levels","text":"Analyzes lower level clusters assigned upper level ones. analysis made several number clusters.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/relate.levels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relates two clustering level results — relate.levels","text":"","code":"relate.levels(   lower,   upper,   defuzzify = FALSE,   excludeFixed = FALSE,   verbose = FALSE,   ... )"},{"path":"https://emf-creaf.github.io/vegclust/reference/relate.levels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relates two clustering level results — relate.levels","text":"lower list objects type vegclust vegclass represent classifications finer level resolution. upper list objects type vegclust vegclass represent classifications broader level resolution. defuzzify logical flag used indicate whether result calling crossmemb deffuzified. excludeFixed logical used indicate whether fixed clusters excluded comparison levels. verbose flag used ask extra screen output. ... Additional parameters function defuzzify.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/relate.levels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relates two clustering level results — relate.levels","text":"list several data frames (see ). , rows items upper columns items lower. names rows columns number clusters vegclust (vegclass) object. nnoise: number low level clusters assigned Noise class (upper objects using Noise clustering). maxnoise: maximum membership value low level clusters Noise class (upper objects using Noise clustering). minmaxall: minimum value (across upper level clusters) maximum membership value observed among lower level clusters. minallsize: minimum value (across upper level clusters) sum membership values across lower level clusters. empty: number upper level clusters (mobile fixed) member among lower level clusters.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/relate.levels.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Relates two clustering level results — relate.levels","text":"pair vegclust (vegclass) objects upper lower, function calls function crossmemb , asked, deffuzifies resulting memberships (calling function defuzzify) several quantities calculated (see 'value' section).","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/relate.levels.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Relates two clustering level results — relate.levels","text":"Miquel De Cáceres, CREAF","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/relate.levels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relates two clustering level results — relate.levels","text":"","code":"## Loads data   data(wetland)  ## This equals the chord transformation  wetland.chord <- as.data.frame(sweep(as.matrix(wetland), 1,                                      sqrt(rowSums(as.matrix(wetland)^2)), \"/\"))  ## Create noise clustering from hierarchical clustering at different number of cluster wetland.hc <- hclust(dist(wetland.chord),method=\"ward\")  #> The \"ward\" method has been renamed to \"ward.D\"; note new \"ward.D2\" wetland.nc1 <- hier.vegclust(wetland.chord, wetland.hc, cmin=2, cmax=6, m = 1.2,                               dnoise=0.75, method=\"NC\") #> PROCESSING 2 MOBILE CLUSTERS #> PROCESSING 3 MOBILE CLUSTERS #> PROCESSING 4 MOBILE CLUSTERS #> PROCESSING 5 MOBILE CLUSTERS #> PROCESSING 6 MOBILE CLUSTERS wetland.nc2 <- hier.vegclust(wetland.chord, wetland.hc, cmin=2, cmax=4, m = 1.2,                               dnoise=0.85, method=\"NC\") #> PROCESSING 2 MOBILE CLUSTERS #> PROCESSING 3 MOBILE CLUSTERS #> PROCESSING 4 MOBILE CLUSTERS  ## Studies the assignment of levels relate.levels(wetland.nc1, wetland.nc2, method=\"cut\") #> $nnoise #>   2 3 4 5 6 #> 2 0 0 0 0 0 #> 3 0 0 0 0 0 #> 4 0 0 0 0 0 #>  #> $maxnoise #>           2         3         4         5         6 #> 2 0.2984744 0.3346209 0.3453526 0.3546016 0.3599861 #> 3 0.2210616 0.2450804 0.2495569 0.2527256 0.2544382 #> 4 0.1776647 0.1947259 0.1975170 0.1988938 0.1994356 #>  #> $minallsize #>           2         3         4         5        6 #> 2 0.6930967 1.0374315 1.3734906 1.7142786 2.061993 #> 3 0.4420566 0.6855948 0.9245805 1.1619556 1.395296 #> 4 0.3406583 0.5351497 0.7243590 0.9123155 1.095565 #>  #> $minmaxall #>           2         3         4         5         6 #> 2 0.4263304 0.4458496 0.4610996 0.4679672 0.4628289 #> 3 0.2294265 0.2663072 0.2816723 0.2972760 0.3070570 #> 4 0.1810541 0.2069985 0.2081818 0.2106483 0.2111411 #>  #> $empty #>   2 3 4 5 6 #> 2 0 0 0 0 0 #> 3 1 0 0 0 0 #> 4 2 1 1 1 1 #>"},{"path":"https://emf-creaf.github.io/vegclust/reference/stratifyvegdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Reshapes community data from individual into stratified form — stratifyvegdata","title":"Reshapes community data from individual into stratified form — stratifyvegdata","text":"Function stratifyvegdata reshapes individual abundance values species abundance values per size class combination size classes. Function .stratifiedvegdata checks input list appropriate properties turns object class 'stratifiedvegdata'.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/stratifyvegdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reshapes community data from individual into stratified form — stratifyvegdata","text":"","code":"stratifyvegdata(   x,   sizes1,   sizes2 = NULL,   treeSel = NULL,   spcodes = NULL,   plotColumn = \"plot\",   speciesColumn = \"species\",   abundanceColumn = \"abundance\",   size1Column = \"size\",   size2Column = NULL,   cumulative = FALSE,   counts = FALSE,   mergeSpecies = FALSE,   verbose = FALSE )  as.stratifiedvegdata(X)"},{"path":"https://emf-creaf.github.io/vegclust/reference/stratifyvegdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reshapes community data from individual into stratified form — stratifyvegdata","text":"x data frame containing individual plant data. Individuals rows, measurements columns. sizes1 numerical vector containing breaks primary size classes ascending order. sizes2 numerical vector containing breaks secondary size classes ascending order. treeSel logical vector specifying rows x used. default (treeSel = NULL) rows taken. spcodes character vector indicating codes species used stratification (species codes beyond appearing x possible). spcodes = NULL species x used. plotColumn name column x contains plot identifiers. speciesColumn name column x contains species names. abundanceColumn name column x contains abundance values. size1Column name column x contains values primary size classes. size2Column name column x contains values secondary size classes. cumulative flag indicate cumulative abundance profiles surfaces desired. counts flag indicate output individual counts instead added abundance values. mergeSpecies flag indicate species identity ignored. leads analyzing structure biomass disregarding species identity. verbose logical flag indicate extra output. X list many elements plot records. element class 'matrix' 'data.frame' species rows strata columns. Furthermore, number rows (species) columns (strata) elements.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/stratifyvegdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reshapes community data from individual into stratified form — stratifyvegdata","text":"functions return object class 'stratifiedvegdata', list matrices, one plot record. element (matrix) many rows species many columns size classes (.e., many elements vector sizes1). Columns named starting 'S' continuing size class (stratum) number. mergeSpecies=TRUE matrices single row (whose name \"\"). sizes2 size2Column supplied stratifyvegdata, function returns object class 'doublestratifiedvegdata', list arrays, one plot record. element (array) three dimensions corresponding species, primary sizes (number elements vector sizes1) secondary sizes (number elements vector sizes2). cumulative=TRUE function returns cumulative abundances (see CAP CAS).","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/stratifyvegdata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reshapes community data from individual into stratified form — stratifyvegdata","text":"individual (row) x, stratifyvegdata assigns size class (stratum) containing size. corresponding abundance value (e.g. crown cover) individual added abundance corresponding species size class (stratum). sizes2 size2Column supplied, function assigns individual (row) x combination size classes (e.g. tree height diameter).","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/stratifyvegdata.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Reshapes community data from individual into stratified form — stratifyvegdata","text":"De Cáceres, M., Legendre, P. & , F. (2013) Dissimilarity measurements size structure ecological communities. Methods Ecology Evolution 4: 1167-1177.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/stratifyvegdata.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Reshapes community data from individual into stratified form — stratifyvegdata","text":"Miquel De Cáceres, CREAF.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/stratifyvegdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reshapes community data from individual into stratified form — stratifyvegdata","text":"","code":"## Load tree data data(treedata)  ## Inspect tree data head(treedata) #>   plotID species height cover      diam #> 1      1       H      4   0.2 1.1328793 #> 2      1       H      4   0.2 1.1630979 #> 3      1       H      4   0.2 1.0639817 #> 4      2       H      4   0.2 1.0959077 #> 5      2       O      1   0.2 0.7445254 #> 6      2       H      4   0.2 1.1514505  ## Define stratum thresholds (4 strata) heights <- seq(0,4, by=0.5) diameters <- seq(0,2, by=0.5)  ## Stratify tree data using heights as structural variable X <- stratifyvegdata(treedata, sizes1=heights, plotColumn=\"plotID\",                      speciesColumn=\"species\", size1Column=\"height\", counts=TRUE)  ## Inspect the second plot record X[[2]] #>   [0,0.5] (0.5,1] (1,1.5] (1.5,2] (2,2.5] (2.5,3] (3,3.5] (3.5,4] #> H       0       0       0       0       0       0       0       3 #> N       0       0       0       0       0       0       0       0 #> O       0       2       0       0       0       0       0       0  ## Stratify tree data using heights as structural variable and cover as abundance Y <- stratifyvegdata(treedata, sizes1=heights, plotColumn=\"plotID\",                      speciesColumn=\"species\", size1Column=\"height\",                       abundanceColumn=\"cover\") Y[[2]] #>   [0,0.5] (0.5,1] (1,1.5] (1.5,2] (2,2.5] (2.5,3] (3,3.5] (3.5,4] #> H       0     0.0       0       0       0       0       0     0.6 #> N       0     0.0       0       0       0       0       0     0.0 #> O       0     0.4       0       0       0       0       0     0.0  ## Stratify tree data using heights and diameters as structural variables Z <- stratifyvegdata(treedata, sizes1=heights, sizes2=diameters, plotColumn=\"plotID\",                      speciesColumn=\"species\", size1Column=\"height\", size2Column=\"diam\",                      counts=TRUE) Z[[2]] #> , , [0,0.5] #>  #>   [0,0.5] (0.5,1] (1,1.5] (1.5,2] (2,2.5] (2.5,3] (3,3.5] (3.5,4] #> H       0       0       0       0       0       0       0       0 #> N       0       0       0       0       0       0       0       0 #> O       0       0       0       0       0       0       0       0 #>  #> , , (0.5,1] #>  #>   [0,0.5] (0.5,1] (1,1.5] (1.5,2] (2,2.5] (2.5,3] (3,3.5] (3.5,4] #> H       0       0       0       0       0       0       0       0 #> N       0       0       0       0       0       0       0       0 #> O       0       2       0       0       0       0       0       0 #>  #> , , (1,1.5] #>  #>   [0,0.5] (0.5,1] (1,1.5] (1.5,2] (2,2.5] (2.5,3] (3,3.5] (3.5,4] #> H       0       0       0       0       0       0       0       3 #> N       0       0       0       0       0       0       0       0 #> O       0       0       0       0       0       0       0       0 #>  #> , , (1.5,2] #>  #>   [0,0.5] (0.5,1] (1,1.5] (1.5,2] (2,2.5] (2.5,3] (3,3.5] (3.5,4] #> H       0       0       0       0       0       0       0       0 #> N       0       0       0       0       0       0       0       0 #> O       0       0       0       0       0       0       0       0 #>"},{"path":"https://emf-creaf.github.io/vegclust/reference/treedata.html","id":null,"dir":"Reference","previous_headings":"","what":"Synthetic vegetation data set with tree data — treedata","title":"Synthetic vegetation data set with tree data — treedata","text":"synthetic data set used illustrate stratification data originally collected individual basis (e.g. forest inventory).","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/treedata.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Synthetic vegetation data set with tree data — treedata","text":"data frame row corresponds different tree. Columns plot code, species identity, tree height, tree diameter cover value.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclass.html","id":null,"dir":"Reference","previous_headings":"","what":"Classifies vegetation communities — vegclass","title":"Classifies vegetation communities — vegclass","text":"Classifies vegetation communities previous fuzzy hard classification.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclass.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classifies vegetation communities — vegclass","text":"","code":"vegclass(y, x)"},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclass.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Classifies vegetation communities — vegclass","text":"y object class vegclust represents previous knowledge. x Community data classified, form site species matrix (vegclust object raw mode) data frame containing distances new sites rows old sites columns (vegclust object distance mode).","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclass.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Classifies vegetation communities — vegclass","text":"Returns object type vegclass following items: method: clustering model used y m: fuzziness exponent y dnoise:distance noise cluster used noise clustering (models NC, NCdd, HNC, HNCdd). set NULL models. eta: reference distance vector used possibilistic clustering (models PCM PCMdd). set NULL models. memb: fuzzy membership matrix. dist2clusters: matrix object distances cluster centers.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclass.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Classifies vegetation communities — vegclass","text":"function uses classification model specified y classify communities (rows) x. vegclust raw mode, function calls first conformveg order cope different sets species. See help .vegclust see example vegclass distance matrices.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclass.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Classifies vegetation communities — vegclass","text":"Davé, R. N. R. Krishnapuram (1997) Robust clustering methods: unified view. IEEE Transactions Fuzzy Systems 5, 270-293. Bezdek, J. C. (1981) Pattern recognition fuzzy objective functions. Plenum Press, New York. Krishnapuram, R. J. M. Keller. (1993) possibilistic approach clustering. IEEE transactions fuzzy systems 1, 98-110. De Cáceres, M., Font, X, Oliva, F. (2010) management numerical vegetation classifications fuzzy clustering methods [Related software]. Journal Vegetation Science 21 (6): 1138-1151.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclass.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Classifies vegetation communities — vegclass","text":"Miquel De Cáceres, CREAF.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclass.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Classifies vegetation communities — vegclass","text":"","code":"## Loads data (38 columns and 33 species) data(wetland)  ## This equals the chord transformation  wetland.chord <- as.data.frame(sweep(as.matrix(wetland), 1,                                       sqrt(rowSums(as.matrix(wetland)^2)), \"/\"))  ## Splits wetland data into two matrices of 30x27 and 11x22 wetland.30 <- wetland.chord[1:30,] wetland.30 <- wetland.30[,colSums(wetland.30)>0] dim(wetland.30) #> [1] 30 27 wetland.11 <- wetland.chord[31:41,] wetland.11 <- wetland.11[,colSums(wetland.11)>0]  dim(wetland.11) #> [1] 11 22  ## Create noise clustering with 3 clusters from the data set with 30 sites.  wetland.30.nc <- vegclust(wetland.30, mobileCenters=3, m = 1.2, dnoise=0.75,                           method=\"NC\", nstart=10)  ## Cardinality of fuzzy clusters (i.e., the number of objects belonging to) wetland.30.nc$size #>        M1        M2        M3  #> 10.188173  8.985131  4.434558   ## Classifies the second set of sites according to the clustering of the first set wetland.11.nc <- vegclass(wetland.30.nc, wetland.11)  ## Fuzzy membership matrix wetland.11.nc$memb #>             M1           M2           M3          N #> 26 0.105685961 0.0045236875 0.0033669216 0.88642343 #> 29 0.150974882 0.0065393301 0.0045768819 0.83790891 #> 33 0.935518312 0.0003252076 0.0002398704 0.06391661 #> 24 0.021754156 0.0049611648 0.0037472206 0.96953746 #> 36 0.099864565 0.0050155850 0.0041759800 0.89094387 #> 37 0.009533221 0.0061170085 0.0049207738 0.97942900 #> 41 0.009665246 0.0340182318 0.0108971494 0.94541937 #> 27 0.006260509 0.0037323210 0.0033883011 0.98661887 #> 32 0.010461589 0.0054301953 0.0045329270 0.97957529 #> 35 0.026084209 0.2221661740 0.0203855023 0.73136411 #> 38 0.004623398 0.7089774056 0.0137079221 0.27269127  ## Obtains hard membership vector, with 'N' for objects that are unclassified defuzzify(wetland.11.nc$memb)$cluster #>   26   29   33   24   36   37   41   27   32   35   38  #>  \"N\"  \"N\" \"M1\"  \"N\"  \"N\"  \"N\"  \"N\"  \"N\"  \"N\"  \"N\" \"M2\""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclust-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Fuzzy Clustering of Vegetation Data — vegclust-package","title":"Fuzzy Clustering of Vegetation Data — vegclust-package","text":"set functions : (1) perform fuzzy clustering vegetation data; (2) assess ecological community similarity basis structure composition.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclust-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fuzzy Clustering of Vegetation Data — vegclust-package","text":"De Caceres et al, 2010 (doi:10.1111/j.1654-1103.2010.01211.x ), De Caceres et al, 2013 (doi:10.1111/2041-210X.12116 ).","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclust-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fuzzy Clustering of Vegetation Data — vegclust-package","text":"Maintainer: Miquel De Cáceres miquelcaceres@gmail.com [ORCID](https://orcid.org/0000-0001-7132-2080)","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclust-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fuzzy Clustering of Vegetation Data — vegclust-package","text":"","code":"## Loads data   data(wetland)  ## This equals the chord transformation  wetland.chord <- as.data.frame(sweep(as.matrix(wetland), 1,                                       sqrt(rowSums(as.matrix(wetland)^2)), \"/\"))  ## Create noise clustering with 3 clusters. Perform 10 starts from random seeds  ## and keep the best solution wetland.nc <- vegclust(wetland.chord, mobileCenters=3, m = 1.2, dnoise=0.75,                         method=\"NC\", nstart=10)"},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclust.html","id":null,"dir":"Reference","previous_headings":"","what":"Vegetation clustering methods — vegclust","title":"Vegetation clustering methods — vegclust","text":"Performs hard fuzzy clustering vegetation data","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vegetation clustering methods — vegclust","text":"","code":"vegclust(   x,   mobileCenters,   fixedCenters = NULL,   method = \"NC\",   m = 2,   dnoise = NULL,   eta = NULL,   alpha = 0.001,   iter.max = 100,   nstart = 1,   maxminJ = 10,   seeds = NULL,   verbose = FALSE )  vegclustdist(   x,   mobileMemb,   fixedDistToCenters = NULL,   method = \"NC\",   m = 2,   dnoise = NULL,   eta = NULL,   alpha = 0.001,   iter.max = 100,   nstart = 1,   seeds = NULL,   verbose = FALSE )"},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vegetation clustering methods — vegclust","text":"x Community data. site--species matrix data frame (vegclust) site--site dissimilarity matrix dist object (vegclustdist). mobileCenters number, vector seeds, coordinates mobile clusters. fixedCenters matrix data frame coordinates fixed (non-mobile) clusters. method clustering model. Current accepted models : \"KM\": K-means hard c-means (MacQueen 1967) \"KMdd\": Hard c-medoids (Krishnapuram et al. 1999) \"FCM\": Fuzzy c-means (Bezdek 1981) \"FCMdd\": Fuzzy c-medoids (Krishnapuram et al. 1999) \"NC\": Noise clustering (Dave Krishnapuram 1997) \"NCdd\": Noise clustering medoids \"HNC\": Hard noise clustering \"HNCdd\": Hard noise clustering medoids \"PCM\": Possibilistic c-means (Krishnapuram Keller 1993) \"PCMdd\": Possibilistic c-medoids m fuzziness exponent used (relevant models except kmeans) dnoise distance noise cluster, relevant noise clustering (NC). eta vector reference distances, relevant possibilistic C-means (PCM). alpha Threshold used stop iterations. maximum difference membership matrix current vs. previous iteration compared value. iter.max maximum number iterations allowed. nstart mobileCenters mobileMemb number, many random sets chosen? maxminJ random starts used, stop least maxminJ runs ended functional value. seeds mobileCenters mobileMemb number, vector indicating objects potential initial centers. NULL objects valid seeds. verbose Flag print extra output. mobileMemb number, vector seeds, starting memberships mobile clusters. fixedDistToCenters matrix data frame distances fixed cluster centers.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vegetation clustering methods — vegclust","text":"Returns object type vegclust following items: mode: raw function vegclust dist function vegclustdist. method: clustering model used m: fuzziness exponent used (m=1 case kmeans) dnoise: distance noise cluster used noise clustering (NC, HNC, NCdd HNCdd). set NULL models. eta: reference distance vector used possibilistic clustering (PCM PCMdd). set NULL models. memb: fuzzy membership matrix. Columns starting \"M\" indicate mobile clusters, whereas columns starting \"F\" indicate fixed clusters. mobileCenters: vegclust used, contains data frame coordinates mobile centers (centroids medoids). vegclustdist used, contain indices mobile medoids models KMdd, FCMdd, HNCdd, NCdd PCMdd; NULL otherwise. fixedCenters: vegclust used, contains data frame coordinates fixed centers (centroids medoids). vegclustdist used, contain indices fixed medoids models KMdd, FCMdd, HNCdd, NCdd PCMdd; NULL otherwise. dist2clusters: matrix object distances cluster centers. Columns starting \"M\" indicate mobile clusters, whereas columns starting \"F\" indicate fixed clusters. withinss: case methods KM, FCM, NC, PCM HNC contains within-cluster sum squares cluster (squared distances cluster center weighted membership). case methods KMdd, FCMdd, NCdd, HNCdd PCMdd contains sum distances cluster (weighted membership). size: number objects belonging cluster. case fuzzy clusters sum memberships given. functional: objective function value (minimum value attained iterations).","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclust.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Vegetation clustering methods — vegclust","text":"Functions vegclust vegclustdist try generalize kmeans function stats three ways. Firstly, allows different clustering models. Clustering models can divided () fuzzy hard; (b) centroid-based medoid-based; (c) Partitioning (KM FCM family), noise clustering (NC family), possibilistic clustering (PCM PCMdd). reader refer original publications better understand differences models. Secondly, users can specify fixed clusters (, centroids change positions iterations). Fixed clusters intended used clusters previously defined new data collected. One may allow new data points form new clusters, points assigned original clusters. case models cluster repulsion (KM, FCM NC) new (mobile) clusters allowed 'push' fixed ones. result, mobile clusters occupy new regions reference space. Thirdly, vegclustdist implements distance-based equivalent vegclust. results vegclust vegclustdist (seeds equal) distance matrix calculated using Euclidean distance (see function dist). Otherwise, equivalence holds resorting principal coordinates analysis. Note data frames matrices used input vegclust defined space species (see conformveg). Unlike kmeans, allows different specific algorithms, updates prototypes (centroids medoids) done objects reassigned (Forgy 1965). order obtain hard cluster definitions, users can apply function defuzzify vegclust object.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclust.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Vegetation clustering methods — vegclust","text":"Forgy, E. W. (1965) Cluster analysis multivariate data: efficiency vs interpretability classifications. Biometrics 21, 768-769. MacQueen, J. (1967) methods classification analysis multivariate observations. Proceedings Fifth Berkeley Symposium Mathematical Statistics Probability, eds L. M. Le Cam J. Neyman, 1, pp. 281-297. Berkeley, CA: University California Press. Davé, R. N. R. Krishnapuram (1997) Robust clustering methods: unified view. IEEE Transactions Fuzzy Systems 5, 270-293. Bezdek, J. C. (1981) Pattern recognition fuzzy objective functions. Plenum Press, New York. Krishnapuram, R., Joshi, ., & Yi, L. (1999). Fuzzy relative k-medoids algorithm application web document snippet clustering. IEEE International Fuzzy Systems (pp. 1281–1286). Krishnapuram, R. J. M. Keller. (1993) possibilistic approach clustering. IEEE transactions fuzzy systems 1, 98-110. De Cáceres, M., Font, X, Oliva, F. (2010) management numerical vegetation classifications fuzzy clustering methods. Journal Vegetation Science 21 (6): 1138-1151.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclust.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Vegetation clustering methods — vegclust","text":"Miquel De Cáceres, CREAF","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclust.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vegetation clustering methods — vegclust","text":"","code":"## Loads data   data(wetland)  ## This equals the chord transformation  wetland.chord <- as.data.frame(sweep(as.matrix(wetland), 1,                                       sqrt(rowSums(as.matrix(wetland)^2)), \"/\"))  ## Create noise clustering with 3 clusters. Perform 10 starts from random seeds  ## and keep the best solution wetland.nc <- vegclust(wetland.chord, mobileCenters=3, m = 1.2, dnoise=0.75,                         method=\"NC\", nstart=10)  ## Fuzzy membership matrix wetland.nc$memb #>              M1           M2           M3            N #> 5  4.631923e-04 1.934923e-04 9.810980e-01 0.0182453582 #> 8  3.853257e-03 2.696115e-03 7.382161e-01 0.2552345091 #> 13 7.864722e-06 4.053434e-06 9.995086e-01 0.0004794780 #> 4  4.326738e-06 2.765733e-06 9.995816e-01 0.0004113170 #> 17 1.771420e-03 2.004422e-03 8.769007e-01 0.1193234439 #> 3  4.507224e-03 3.371931e-03 2.317281e-01 0.7603927883 #> 9  5.545494e-03 4.058727e-03 4.289602e-02 0.9474997554 #> 21 5.009408e-05 1.348443e-05 9.973078e-01 0.0026285984 #> 16 4.775704e-03 1.736775e-03 7.258593e-01 0.2676282154 #> 14 3.767558e-04 1.439041e-04 9.777028e-01 0.0217765177 #> 2  4.978630e-06 2.224694e-06 9.996401e-01 0.0003527178 #> 15 1.039574e-03 6.087027e-04 8.643911e-01 0.1339606695 #> 1  1.936547e-05 6.868146e-06 9.985536e-01 0.0014201274 #> 7  8.933405e-03 4.168937e-03 2.818186e-01 0.7050790391 #> 10 7.932120e-03 3.627818e-03 5.517684e-02 0.9332632237 #> 40 9.982441e-01 2.184429e-05 2.813868e-05 0.0017058790 #> 23 8.786846e-01 1.394202e-03 1.412218e-02 0.1057990526 #> 25 9.699884e-01 2.218667e-04 7.293952e-03 0.0224957781 #> 22 3.255074e-01 3.033436e-03 4.872820e-01 0.1841771737 #> 20 9.620317e-01 3.191525e-04 6.151673e-04 0.0370339485 #> 6  9.950089e-01 1.033829e-04 5.125278e-05 0.0048364332 #> 18 9.975305e-01 2.704033e-05 1.728555e-05 0.0024251398 #> 12 9.995425e-01 5.011688e-06 3.722050e-06 0.0004487221 #> 39 9.844351e-01 2.760139e-04 2.090807e-04 0.0150798520 #> 19 9.972399e-01 3.986057e-05 1.618438e-04 0.0025584371 #> 11 8.855198e-01 1.770112e-03 1.113401e-03 0.1115966737 #> 30 6.221509e-03 3.470612e-02 6.039936e-03 0.9530324381 #> 34 1.656704e-04 9.705787e-01 1.628479e-04 0.0290927778 #> 28 9.042788e-03 3.684396e-02 6.661688e-03 0.9474515647 #> 31 2.265240e-04 9.585717e-01 2.690234e-04 0.0409327962 #> 26 1.525082e-01 1.885451e-02 5.030634e-03 0.8236066965 #> 29 1.948998e-01 4.811058e-02 6.861306e-03 0.7501283180 #> 33 9.771155e-01 5.025501e-04 1.363616e-04 0.0222455946 #> 24 3.259673e-05 9.987283e-01 7.966515e-06 0.0012311549 #> 36 4.793132e-04 9.955968e-01 2.857521e-05 0.0038953389 #> 37 3.670480e-05 9.964571e-01 2.801749e-05 0.0034781754 #> 41 1.520015e-03 8.473454e-01 7.745152e-03 0.1433894721 #> 27 7.144360e-03 2.477801e-02 5.295813e-03 0.9627818187 #> 32 1.140535e-02 5.088722e-02 7.431382e-03 0.9302760570 #> 35 1.950680e-02 1.325170e-02 3.255441e-01 0.6416974428 #> 38 2.323373e-03 2.545335e-03 8.427572e-01 0.1523740657  ## Cardinality of fuzzy clusters (i.e., the number of objects belonging to each cluster) wetland.nc$size #>       M1       M2       M3  #> 11.41565  6.02761 12.49528   ## Obtains hard membership vector, with 'N' for objects that are unclassified defuzzify(wetland.nc$memb)$cluster #>    5    8   13    4   17    3    9   21   16   14    2   15    1    7   10   40  #> \"M3\" \"M3\" \"M3\" \"M3\" \"M3\"  \"N\"  \"N\" \"M3\" \"M3\" \"M3\" \"M3\" \"M3\" \"M3\"  \"N\"  \"N\" \"M1\"  #>   23   25   22   20    6   18   12   39   19   11   30   34   28   31   26   29  #> \"M1\" \"M1\" \"M3\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\" \"M1\"  \"N\" \"M2\"  \"N\" \"M2\"  \"N\"  \"N\"  #>   33   24   36   37   41   27   32   35   38  #> \"M1\" \"M2\" \"M2\" \"M2\" \"M2\"  \"N\"  \"N\"  \"N\" \"M3\"   ## The same result is obtained with a matrix of chord distances wetland.d <- dist(wetland.chord) wetland.d.nc <- vegclustdist(wetland.d, mobileMemb=3, m = 1.2, dnoise=0.75,                               method=\"NC\", nstart=10)"},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclust2kmeans.html","id":null,"dir":"Reference","previous_headings":"","what":"Reshapes as kmeans object — vegclust2kmeans","title":"Reshapes as kmeans object — vegclust2kmeans","text":"function casts object class vegclust object class kmeans.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclust2kmeans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reshapes as kmeans object — vegclust2kmeans","text":"","code":"vegclust2kmeans(x)"},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclust2kmeans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reshapes as kmeans object — vegclust2kmeans","text":"x object class vegclust casted, method=\"KM\" mode=\"raw\".","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclust2kmeans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reshapes as kmeans object — vegclust2kmeans","text":"object class kmeans","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclust2kmeans.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Reshapes as kmeans object — vegclust2kmeans","text":"Miquel De Cáceres, CREAF","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclust2kmeans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reshapes as kmeans object — vegclust2kmeans","text":"","code":"## Loads data   data(wetland)  ## This equals the chord transformation  wetland.chord <- as.data.frame(sweep(as.matrix(wetland), 1,                                       sqrt(rowSums(as.matrix(wetland)^2)), \"/\"))  ## Create noise clustering with 3 clusters. Perform 10 starts from random seeds  wetland.vc <- vegclust(wetland.chord, mobileCenters=3,                         method=\"KM\", nstart=10)  ## Reshapes as kmeans object wetland.km <- vegclust2kmeans(wetland.vc) wetland.km #> K-means clustering with 3 clusters of sizes 14, 10, 17 #>  #> Cluster means: #>       Abefic     Merhed     Alyvag     Pancam     Abemos     Melcor     Ludoct #> 1 0.00000000 0.00000000 0.04696958 0.07606533 0.01558699 0.15317754 0.00000000 #> 2 0.01825742 0.06770211 0.00000000 0.35635911 0.01458650 0.27504998 0.01889822 #> 3 0.00000000 0.00000000 0.00000000 0.02725749 0.00000000 0.06157316 0.00000000 #>       Eupvac     Echpas     Passcr       Poa2     Carhal     Dendio     Casobt #> 1 0.05023873 0.06646064 0.00000000 0.01041893 0.06911470 0.00000000 0.00000000 #> 2 0.20498936 0.10174214 0.02581989 0.00000000 0.00000000 0.00000000 0.00000000 #> 3 0.03879374 0.04762643 0.00000000 0.00000000 0.03679444 0.01572125 0.01631471 #>       Aesind     Cyprot     Ipocop     Cynarc     Walind    Sessp.     Phynod #> 1 0.07475403 0.08126971 0.01262691 0.01262691 0.06377158 0.1041481 0.71534308 #> 2 0.01889822 0.17597447 0.03974967 0.43238581 0.07754611 0.1569788 0.06361634 #> 3 0.00000000 0.00000000 0.00000000 0.00000000 0.06827998 0.1437923 0.00000000 #>      Echell     Helind     Ipoaqu    Orysp.    Elesp.     Psespi   Ludads #> 1 0.1191200 0.17218890 0.04775048 0.1720463 0.1377765 0.02691262 0.000000 #> 2 0.1120500 0.01889822 0.03657589 0.0400000 0.0000000 0.00000000 0.000000 #> 3 0.0491431 0.12531919 0.05532759 0.6491987 0.1535492 0.19245622 0.204177 #>       Polatt       Poa1     Helcri     Physp.     Goopur #> 1 0.00000000 0.01282895 0.01282895 0.00000000 0.00000000 #> 2 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 #> 3 0.09678166 0.00000000 0.00000000 0.01153624 0.01153624 #>  #> Clustering vector: #>  [1] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 1 1 1 2 2 2 2 2 #> [39] 2 3 3 #>  #> Within cluster sum of squares by cluster: #> [1] 4.502115 4.684155 6.968455 #>  #> Available components: #>  #> [1] \"cluster\"      \"centers\"      \"totss\"        \"withinss\"     \"tot.withinss\" #> [6] \"betweenss\"    \"size\"         \"iter\"         \"ifault\""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclustIndex.html","id":null,"dir":"Reference","previous_headings":"","what":"Fuzzy evaluation statistics — vegclustIndex","title":"Fuzzy evaluation statistics — vegclustIndex","text":"Computes several evaluation statistics fuzzy clustering results objects class vegclust.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclustIndex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fuzzy evaluation statistics — vegclustIndex","text":"","code":"vegclustIndex(y)"},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclustIndex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fuzzy evaluation statistics — vegclustIndex","text":"y object class vegclust membership matrix.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclustIndex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fuzzy evaluation statistics — vegclustIndex","text":"Returns vector four values: partition coefficient (PC), normalized partition coefficient (PCN), partition entropy (PE) normalized partition entropy (PEN).","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclustIndex.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fuzzy evaluation statistics — vegclustIndex","text":"statistics conceived computed fuzzy partitions, ones coming Fuzzy C-means (Bezdek 1981). Maximum values PCN minimum values PEN can used criteria choose number clusters.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclustIndex.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fuzzy evaluation statistics — vegclustIndex","text":"Bezdek, J. C. (1981) Pattern recognition fuzzy objective functions. Plenum Press, New York.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclustIndex.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fuzzy evaluation statistics — vegclustIndex","text":"Miquel De Cáceres, CREAF.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegclustIndex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fuzzy evaluation statistics — vegclustIndex","text":"","code":"## Loads data   data(wetland)  ## This equals the chord transformation  wetland.chord <- as.data.frame(sweep(as.matrix(wetland), 1,                                       sqrt(rowSums(as.matrix(wetland)^2)), \"/\"))  ## Create noise clustering with 2, 3 and 4 clusters. Perform 10 starts from random seeds  ## and keep the best solutions wetland.fcm2 <- vegclust(wetland.chord, mobileCenters=2, m = 1.2, method=\"FCM\", nstart=10) wetland.fcm3 <- vegclust(wetland.chord, mobileCenters=3, m = 1.2, method=\"FCM\", nstart=10) wetland.fcm4 <- vegclust(wetland.chord, mobileCenters=4, m = 1.2, method=\"FCM\", nstart=10)  ## Compute statistics. Both PCN and PEN indicate that three groups are more advisable  ## than 2 or 4. print(vegclustIndex(wetland.fcm2)) #>        PC       PCN        PE       PEN  #> 0.9201143 0.8402286 0.1462538 0.1537540  print(vegclustIndex(wetland.fcm3)) #>        PC       PCN        PE       PEN  #> 0.9366770 0.9050155 0.1267064 0.1367095  print(vegclustIndex(wetland.fcm4)) #>        PC       PCN        PE       PEN  #> 0.9251150 0.9001534 0.1506888 0.1669794"},{"path":"https://emf-creaf.github.io/vegclust/reference/vegdiststruct.html","id":null,"dir":"Reference","previous_headings":"","what":"Structural and compositional dissimilarity — vegdiststruct","title":"Structural and compositional dissimilarity — vegdiststruct","text":"Function calculate dissimilarity ecological communities taking account composition size organisms.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegdiststruct.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Structural and compositional dissimilarity — vegdiststruct","text":"","code":"vegdiststruct(   x,   y = NULL,   paired = FALSE,   type = \"cumulative\",   method = \"bray\",   transform = NULL,   classWeights = NULL )"},{"path":"https://emf-creaf.github.io/vegclust/reference/vegdiststruct.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Structural and compositional dissimilarity — vegdiststruct","text":"x stratified vegetation data set (see function stratifyvegdata), set cummulative abundance profiles (see function CAP) set cummulative abundance surfaces (see function CAS). y second stratified vegetation data set (see function stratifyvegdata), second set cummulative abundance profiles (see function CAP) second set cummulative abundance surfaces (see function CAS) object x compared. paired relevant y != NULL. paired = TRUE pairwise comparisons calculated elements x y (x y need length). paired = FALSE objects x compared objects y. type Whether dissimilarities pairs sites calculated differences cummulative abundance (\"cumulative\"), total abundance (\"total\") volumes cumulative abundance profiles (\"volume\"). method dissimilarity coefficient calculate (see details). transform function name function applied cumulative abundance value. classWeights numerical vector matrix containing weight size class combination size classes (see functions CAP2matrix CAS2matrix). NULL, function assumes classes equal weight.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegdiststruct.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Structural and compositional dissimilarity — vegdiststruct","text":"Returns object class 'dist'.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegdiststruct.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Structural and compositional dissimilarity — vegdiststruct","text":"six different coefficients available described De Caceres et al. (2013): (1) method=\"bray\" percentage difference (alias Bray-Curtis dissimilarity); (2) method=\"ruzicka\" Ruzicka index (generalization Jaccard); (3) method=\"kulczynski\" Kulczynski dissimilarity index; (4) method=\"ochiai\" complement quantitative generalization Ochiai index similarity; (5) method=\"canberra\" Canberra index (Adkins form); (6) method=\"relman\" relativized Manhattan coefficient (Whittaker's index association). Currently, function also supports (7) method=\"manhattan\" city block metric.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/vegdiststruct.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Structural and compositional dissimilarity — vegdiststruct","text":"De Cáceres, M., Legendre, P. & , F. (2013) Dissimilarity measurements size structure ecological communities. Methods Ecology Evolution 4: 1167-1177.","code":""},{"path":[]},{"path":"https://emf-creaf.github.io/vegclust/reference/vegdiststruct.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Structural and compositional dissimilarity — vegdiststruct","text":"","code":"## Load stratified data data(medreg)  ## Check that 'medreg' has correct class class(medreg) #> [1] \"stratifiedvegdata\" \"list\"               ## Create cumulative abundance profile (CAP) for each plot medreg.CAP <- CAP(medreg)  ## Create dissimilarity (percentage difference) matrix using profiles medreg.D <- vegdiststruct(medreg, method=\"bray\")  ## Create dissimilarity (percentage difference) matrix using abundances medreg.D2 <- vegdiststruct(medreg, method=\"bray\", type=\"total\")  ## Calculate correlation cor(as.vector(medreg.D), as.vector(medreg.D2)) #> [1] 0.8951487"},{"path":"https://emf-creaf.github.io/vegclust/reference/wetland.html","id":null,"dir":"Reference","previous_headings":"","what":"Wetland vegetation data set Vegetation of the Adelaide river alluvial plain (Australia). This data set was published by Bowman & Wilson (1987) and used in Dale (1988) to compare fuzzy classification approaches. — wetland","title":"Wetland vegetation data set Vegetation of the Adelaide river alluvial plain (Australia). This data set was published by Bowman & Wilson (1987) and used in Dale (1988) to compare fuzzy classification approaches. — wetland","text":"Wetland vegetation data set Vegetation Adelaide river alluvial plain (Australia). data set published Bowman & Wilson (1987) used Dale (1988) compare fuzzy classification approaches.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/wetland.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Wetland vegetation data set Vegetation of the Adelaide river alluvial plain (Australia). This data set was published by Bowman & Wilson (1987) and used in Dale (1988) to compare fuzzy classification approaches. — wetland","text":"data frame 41 sites (rows) 33 species (columns). Abundance values represented abundance classes.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/wetland.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Wetland vegetation data set Vegetation of the Adelaide river alluvial plain (Australia). This data set was published by Bowman & Wilson (1987) and used in Dale (1988) to compare fuzzy classification approaches. — wetland","text":"Bowman, D. M. J. S. B. . Wilson. 1986. Wetland vegetation pattern Adelaide River flood plain, Northern Territory, Australia. Proceedings Royal Society Queensland 97:69-77.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/wetland.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Wetland vegetation data set Vegetation of the Adelaide river alluvial plain (Australia). This data set was published by Bowman & Wilson (1987) and used in Dale (1988) to compare fuzzy classification approaches. — wetland","text":"Dale, M. B. 1988. fuzzy approaches phytosociology. Ideals instances. Folia geobotanica et phytotaxonomica 23:239-274.","code":""},{"path":"https://emf-creaf.github.io/vegclust/reference/wetland.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wetland vegetation data set Vegetation of the Adelaide river alluvial plain (Australia). This data set was published by Bowman & Wilson (1987) and used in Dale (1988) to compare fuzzy classification approaches. — wetland","text":"","code":"data(wetland)"},{"path":"https://emf-creaf.github.io/vegclust/news/index.html","id":"version-203","dir":"Changelog","previous_headings":"","what":"Version 2.0.3","title":"Version 2.0.3","text":"CRAN release: 2025-05-19 Package documentation Roxygen","code":""},{"path":"https://emf-creaf.github.io/vegclust/news/index.html","id":"version-202","dir":"Changelog","previous_headings":"","what":"Version 2.0.2","title":"Version 2.0.2","text":"CRAN release: 2022-08-25 Bug corrected medoid-based methods allowed chosing object medoid different clusters. Issue reported Alexander Bauer (Department Statistics LMU Munich). Exclude duplicate objects exact position potential seeds","code":""},{"path":"https://emf-creaf.github.io/vegclust/news/index.html","id":"version-201","dir":"Changelog","previous_headings":"","what":"Version 2.0.1","title":"Version 2.0.1","text":"Translation vignettes Rmarkdown","code":""},{"path":"https://emf-creaf.github.io/vegclust/news/index.html","id":"version-200","dir":"Changelog","previous_headings":"","what":"Version 2.0.0","title":"Version 2.0.0","text":"CRAN release: 2021-06-01 IMPORTANT: Functions Community Trajectory Analysis moved package ‘ecotraj’, available GitHub (https://github.com/emf-creaf/ecotraj/) soon also CRAN.","code":""},{"path":"https://emf-creaf.github.io/vegclust/news/index.html","id":"version-180","dir":"Changelog","previous_headings":"","what":"Version 1.8.0","title":"Version 1.8.0","text":"Update function ‘trajectoryAngles2D’ Anthony Sturbois","code":""},{"path":"https://emf-creaf.github.io/vegclust/news/index.html","id":"version-179","dir":"Changelog","previous_headings":"","what":"Version 1.7.9","title":"Version 1.7.9","text":"New option ‘trajectoryLengths’ ‘trajectoryAngles’ calculate distances angles relative initial survey New functions ‘trajectoryLengths2D’ ‘trajectoryAngles2D’ Anthony Sturbois Bug correction vegdiststruct Update CTA vignette (suggestions P. Legendre)","code":""},{"path":"https://emf-creaf.github.io/vegclust/news/index.html","id":"version-178","dir":"Changelog","previous_headings":"","what":"Version 1.7.8","title":"Version 1.7.8","text":"New option ‘trajectoryPCoA’ ‘trajectoryPlot’ draw survey labels","code":""},{"path":"https://emf-creaf.github.io/vegclust/news/index.html","id":"version-177","dir":"Changelog","previous_headings":"","what":"Version 1.7.7","title":"Version 1.7.7","text":"CRAN release: 2019-01-08 Bug correction ‘stratifyvegdata’","code":""},{"path":"https://emf-creaf.github.io/vegclust/news/index.html","id":"version-176","dir":"Changelog","previous_headings":"","what":"Version 1.7.6","title":"Version 1.7.6","text":"Adapt Rcpp changes","code":""},{"path":"https://emf-creaf.github.io/vegclust/news/index.html","id":"version-175","dir":"Changelog","previous_headings":"","what":"Version 1.7.5","title":"Version 1.7.5","text":"Now trajectory angles measured direction first segment direction second segment. Now mean sd trajectory angles calculated using functions package ‘circular’ Parameter ‘add’ added community trajectory analysis deactivate constant addition triplets violating triangle inequality. Update “centerTrajectories” according Anderson (2017) Improved CTA vignette","code":""},{"path":"https://emf-creaf.github.io/vegclust/news/index.html","id":"version-174","dir":"Changelog","previous_headings":"","what":"Version 1.7.4","title":"Version 1.7.4","text":"CRAN release: 2018-05-29 Improvement parameter checking function ‘stratifyvegdata’ Documentation avoca data set New function ‘trajectoryPlot’","code":""},{"path":"https://emf-creaf.github.io/vegclust/news/index.html","id":"version-173","dir":"Changelog","previous_headings":"","what":"Version 1.7.3","title":"Version 1.7.3","text":"New function ‘trajectoryConvergence’ New function ‘trajectoryDirectionality’ New function ‘centerTrajectories’","code":""},{"path":"https://emf-creaf.github.io/vegclust/news/index.html","id":"version-172","dir":"Changelog","previous_headings":"","what":"Version 1.7.2","title":"Version 1.7.2","text":"New function ‘trajectoryAngles’. New function ‘trajectoryProjection’. New vignette trajectory analysis.","code":""},{"path":"https://emf-creaf.github.io/vegclust/news/index.html","id":"version-171","dir":"Changelog","previous_headings":"","what":"Version 1.7.1","title":"Version 1.7.1","text":"CRAN release: 2017-09-17 Package encoding. Changed package author description.","code":""},{"path":"https://emf-creaf.github.io/vegclust/news/index.html","id":"version-170","dir":"Changelog","previous_headings":"","what":"Version 1.7.0","title":"Version 1.7.0","text":"NEW feature: Trajectory analysis. Functions ‘trajectoryDistances’, ‘trajectoryLengths’ ’trajectoryPCoA. Added option ‘trajectoryDistances’ allow different symmetrization functions (e.g. min) addition ‘mean’.","code":""}]
