<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>How to use the vegclust package • vegclust</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png">
<link rel="icon" type="”image/svg+xml”" href="../favicon.svg">
<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" sizes="any" href="../favicon.ico">
<link rel="manifest" href="../site.webmanifest">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="How to use the vegclust package">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-primary" data-bs-theme="dark" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">vegclust</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">2.0.3</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/MedRegExample.html">Describing vegetation in terms of structure and composition</a></li>
    <li><a class="dropdown-item" href="../articles/VegetationClassification.html">How to use the vegclust package</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/emf-creaf/vegclust/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>How to use the vegclust package</h1>
                        <h4 data-toc-skip class="author">Miquel De
Cáceres, CREAF, Barcelona, Spain</h4>
                        <h4 data-toc-skip class="author">Susan Wiser,
Landcare Research, Lincoln, New Zealand</h4>
            
            <h4 data-toc-skip class="date">2025-05-21</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/emf-creaf/vegclust/blob/HEAD/vignettes/VegetationClassification.Rmd" class="external-link"><code>vignettes/VegetationClassification.Rmd</code></a></small>
      <div class="d-none name"><code>VegetationClassification.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<div class="section level3">
<h3 id="what-is-this-tutorial-about">What is this tutorial about?<a class="anchor" aria-label="anchor" href="#what-is-this-tutorial-about"></a>
</h3>
<p>Classification of vegetation plot records involves different
activities, including the design of an appropriate vegetation survey,
the use of a classification method to group vegetation observations and
the characterization, validation and naming of the resulting vegetation
groups. In this tutorial we focus on only one of this steps, namely to
group vegetation observations, and we show how to conduct it with the
help of the R package <code>vegclust</code>. Before starting our
examples we need to load the <code>vegclust</code> package and package
<code>vegan</code>:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://emf-creaf.github.io/vegclust/">vegclust</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/vegandevs/vegan" class="external-link">vegan</a></span><span class="op">)</span></span>
<span><span class="co">#&gt; Loading required package: permute</span></span>
<span><span class="co">#&gt; Loading required package: lattice</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="example-vegetation-data">Example vegetation data<a class="anchor" aria-label="anchor" href="#example-vegetation-data"></a>
</h3>
<p>In order to illustrate the functions in <code>vegclust</code> we will
use a small wetland vegetation data set, consisting of 41 sites and 33
species and published by <span class="citation">Bowman and Wilson
(1986)</span>. The data is included with the <code>vegclust</code>
package:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="va">wetland</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/dim.html" class="external-link">dim</a></span><span class="op">(</span><span class="va">wetland</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 41 33</span></span></code></pre></div>
<p>For a number of reasons that we will not detail here, the Euclidean
distance is not an appropriate index to measure the resemblance in
species composition between vegetation plot records. Therefore, we
transform our community data using the chord transformation <span class="citation">(Legendre and Gallagher 2001)</span>, which divides
each value by the norm of the row vector of the corresponding site:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetlandchord</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/vegan/man/decostand.html" class="external-link">decostand</a></span><span class="op">(</span><span class="va">wetland</span>,<span class="st">"normalize"</span><span class="op">)</span></span></code></pre></div>
<p>Function <code><a href="https://rdrr.io/pkg/vegan/man/decostand.html" class="external-link">decostand()</a></code> is provided within the
<code>vegan</code> package. The Euclidean distance on the transformed
data is equal to the chord distance <span class="citation">(Orlóci
1967)</span> with respect to the raw community data:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dchord</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/dist.html" class="external-link">dist</a></span><span class="op">(</span><span class="va">wetlandchord</span><span class="op">)</span></span></code></pre></div>
<p>In some of our examples we will use the R objects
<code>wetlandchord</code> or <code>dchord</code> indistinctively,
because package <code>vegclust</code> allows vegetation to be classified
from either a site-by-species data table or from a site-by-site
dissimilarity matrix. In the next section we briefly explain the bases
of the classification methods that are provided in the
<code>vegclust</code> package. We later show how to run those methods
using functions in the package.</p>
</div>
</div>
<div class="section level2">
<h2 id="clustering-methods-in-vegclust">Clustering methods in <code>vegclust</code><a class="anchor" aria-label="anchor" href="#clustering-methods-in-vegclust"></a>
</h2>
<div class="section level3">
<h3 id="resemblance-space">Resemblance space<a class="anchor" aria-label="anchor" href="#resemblance-space"></a>
</h3>
<p>Generally speaking, the goal of clustering is to derive
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
‘natural’ classes or clusters from a set of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
unlabelled objects. Those objects inside a `natural’ cluster show a
certain degree of closeness or similarity and the cluster itself shows a
certain degree of isolation from other clusters. In classification of
vegetation the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
‘objects’ to be grouped are samples of plant communities (i.e. plot
records or relevés) and the goal is to define vegetation types.</p>
<p>When speaking of ‘proximity’ or ‘similarity’, we implicitly assume
there is a procedure to assess the degree of resemblance between the
objects to be grouped. This procedure usually involves describing our
objects using a set of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
features (these are normally species in the case of vegetation) and
specifying a resemblance measure (e.g. distance or dissimilarity). Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐗</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>x</mi><mrow><mi>j</mi><mi>s</mi></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{X}=[x_{js}]</annotation></semantics></math>
be a site-by-species data table of dimensions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">n\times p</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mrow><mi>j</mi><mi>s</mi></mrow></msub><annotation encoding="application/x-tex">x_{js}</annotation></semantics></math>
is the abundance of species
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>
in site
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>,
and let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>
be an appropriate dissimilarity or distance measure.</p>
<p>Another way to formalize the resemblance between objects is to
directly provide the similarity or dissimilarity between pairs of
objects in a symmetric resemblance matrix. Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐃</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>d</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{D}=[d_{ij}]</annotation></semantics></math>
be a symmetric dissimilarity matrix of dimensions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n\times n</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mi>d</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐱</mi><mi>i</mi></msub><mo>,</mo><msub><mi>𝐱</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">d_{ij} = d(\mathbf{x}_i,\mathbf{x}_j)</annotation></semantics></math>
is the dissimilarity between objects
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>.
In classification of vegetation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mi>d</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐱</mi><mi>i</mi></msub><mo>,</mo><msub><mi>𝐱</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">d_{ij} = d(\mathbf{x}_i,\mathbf{x}_j)</annotation></semantics></math>
may represent the compositional dissimilarity between the two plant
communities
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>,
but it could be based on other vegetation attributes such as
physiognomy.</p>
<p>Regardless of whether we use
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>,
we will speak here of <em>resemblance space</em> and our objects (plant
communities) will be formally represented as points in this space.
Although we do not cover this topic in detail here, the reader should be
aware that building an appropriate resemblance space is critical to
achieving a vegetation classification that fits a given purpose. The
results of the classification exercise may be completely different
depending on the way the resemblance space is defined.</p>
</div>
<div class="section level3">
<h3 id="prototype-based-clustering">Prototype-based clustering<a class="anchor" aria-label="anchor" href="#prototype-based-clustering"></a>
</h3>
<p><em>Prototype-based</em> clustering methods assume that the
properties of objects in a cluster can be represented using a cluster
<em>prototype</em>, which is formalized as a point in the resemblance
space. The problem is thus to find
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
prototypes and assign the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
objects according to their proximity to those prototypes, such that the
resulting clusters are compact and isolated one from another.</p>
<p>All the clustering methods discussed here follow an <em>alternate
optimization</em> scheme, meaning that one group of parameters (e.g. the
membership matrix) is optimized by holding the other group (e.g. the
cluster prototypes) fixed and vice versa. Assuming an initial cluster
configuration, this is achieved by iterating the following three
steps:</p>
<ol style="list-style-type: decimal">
<li>Determine the prototype of each cluster
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>.</li>
<li>Calculate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">e_{ij}</annotation></semantics></math>,
the distance from each object
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
to the prototype of each cluster
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>.</li>
<li>Calculate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>u</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">u_{ij}</annotation></semantics></math>,
the (hard or fuzzy) membership of each object
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
to each cluster
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
(i.e. re-assign all objects into clusters).</li>
</ol>
<p>Each iteration of the alternate optimization algorithm improves the
<em>objective function</em> of the clustering method. The alternate
optimization algorithm stops when there are no further changes in object
memberships. More technically, it stops if the maximum difference in
object membership values of the last two iterations does not exceed a
user-specified threshold. The starting configuration of clusters is a
critical issue in this kind of classification methods, because the
iterations can result in the alternate optimization algorithm getting
stuck in a suboptimal value of the objective function. For this reason,
several executions of the algorithm are usually tried, each one using a
different starting configuration.</p>
</div>
<div class="section level3">
<h3 id="clustering-models">Clustering models<a class="anchor" aria-label="anchor" href="#clustering-models"></a>
</h3>
<p>There are several prototype-based clustering models in the
<code>vegclust</code> package; all of which follow the iterative
algorithm presented above. The differences between clustering models
arise due to differences in the specific implementation of each step,
resulting from different assumptions of how clusters should be defined.
The clustering models can be divided according to their properties
into:</p>
<ol style="list-style-type: lower-alpha">
<li>Whether object memberships are <strong>fuzzy</strong> or
<strong>hard</strong> (crisp).</li>
<li>Whether cluster prototypes are <strong>centroids</strong> or
<strong>medoids</strong>.</li>
<li>How outlier objects are handled, which gives three kinds of models:
<strong>partitive</strong>, <strong>noise clustering</strong> or
<strong>possibilistic clustering</strong>.</li>
</ol>
<p>In the following subsections we describe the implications of each of
these decisions.</p>
<div class="section level4">
<h4 id="hard-crisp-or-fuzzy-memberships">Hard (crisp) or fuzzy memberships<a class="anchor" aria-label="anchor" href="#hard-crisp-or-fuzzy-memberships"></a>
</h4>
<p>With the kind of classification methods described here, it is
costumary to represent the classification of objects into groups using a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">c\times n</annotation></semantics></math>
membership matrix,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐔</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>u</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{U}=[u_{ij}]</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>u</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">u_{ij}</annotation></semantics></math>
is the degree of membership of object
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
in cluster
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>.
The classification is said to be <em>hard</em> when the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>u</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">u_{ij}</annotation></semantics></math>
values are either 0 (object
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
DOES NOT belong to cluster
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>)
or 1 (object
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
DOES belong to cluster
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>).
In contrast, if the classification is <em>fuzzy</em> the membership of
its objects is expressed through a degree of membership bounded between
0 (i.e. the object does not belong to the set at all) and 1 (i.e. the
object belongs completely to the set).</p>
<p>The advantages of using fuzzy set theory in vegetation classification
are that it acknowledges the individualistic concept of species
distribution across gradients of vegetation composition <span class="citation">(Moravec 1989)</span>, and therefore avoids assuming
that vegetation observations (e.g. releves) must be unequivocal
representatives of a type without no admixture of any other types <span class="citation">(Dale 1995)</span>.</p>
</div>
<div class="section level4">
<h4 id="centroids-or-medoids">Centroids or medoids<a class="anchor" aria-label="anchor" href="#centroids-or-medoids"></a>
</h4>
<p>The <em>centroid</em> of a cluster
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
that contains
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>i</mi></msub><annotation encoding="application/x-tex">n_i</annotation></semantics></math>
objects is a vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐜</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathbf{c}_i</annotation></semantics></math>
whose coordinates are the average, in each dimension
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>,
of the coordinates of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>i</mi></msub><annotation encoding="application/x-tex">n_i</annotation></semantics></math>
objects belonging to the cluster. In vector notation:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐜</mi><mi>i</mi></msub><mo>=</mo><mfrac><mrow><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>i</mi></msub></munderover><msub><mi>𝐱</mi><mi>j</mi></msub></mrow><msub><mi>n</mi><mi>i</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\begin{equation}\label{eq:centroid}
\mathbf{c}_{i} = \frac{\sum_{j=1}^{n_i}{\mathbf{x}_{j}}}{n_i}
\end{equation}</annotation></semantics></math> The centroid has the
property that minimizes the sum of squared Euclidean distances between
itself and each point belonging to the cluster. Equation~ can be
generalized to the case of a fuzzy cluster by weighting the coordinates
each object by its degree of membership to the cluster,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>u</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">u_{ij}</annotation></semantics></math>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐜</mi><mi>i</mi></msub><mo>=</mo><mfrac><mrow><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><msubsup><mi>u</mi><mrow><mi>i</mi><mi>j</mi></mrow><mi>m</mi></msubsup><msub><mi>𝐱</mi><mi>j</mi></msub></mrow></mrow><mrow><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msubsup><mi>u</mi><mrow><mi>i</mi><mi>j</mi></mrow><mi>m</mi></msubsup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\begin{equation}
\mathbf{c}_{i} = \frac{\sum_{j=1}^n{u_{ij}^m\mathbf{x}_{j}}}{\sum_{j=1}^n{u_{ij}^m}} 
\end{equation}</annotation></semantics></math> In the former equation,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">m &gt; 0</annotation></semantics></math>
is the <em>fuzziness exponent</em>, which is used to modulate the
influence of fuzzy memberships in the calculation of the centroids. If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>
is very large only the objects whose membership is close to 1 will have
an influence on the centroid. On the contrary, if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>
is small (i.e. close to 0) then all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
objects will influence the centroid equally and it will approach the
overall data center.</p>
<p>A <em>medoid</em> of a cluster
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
that contains
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>i</mi></msub><annotation encoding="application/x-tex">n_i</annotation></semantics></math>
objects is defined as the object, chosen among the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>i</mi></msub><annotation encoding="application/x-tex">n_i</annotation></semantics></math>
objects, for which the sum of dissimilarities to all the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>i</mi></msub><annotation encoding="application/x-tex">n_i</annotation></semantics></math>
objects is minimal i.e. it is a most centrally located point in the
cluster. Formally, the medoid is the object
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
for which:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>i</mi></msub></munderover><mrow><mi>d</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐱</mi><mi>k</mi></msub><mo>,</mo><msub><mi>𝐱</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">\begin{equation}
\sum_{j=1}^{n_i}{d(\mathbf{x}_k,\mathbf{x}_j)}
\end{equation}</annotation></semantics></math> is minimal. When using
fuzzy logic, the medoid of cluster
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
is defined as the object
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
(among all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
objects) that minimizes:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><msubsup><mi>u</mi><mrow><mi>i</mi><mi>j</mi></mrow><mi>m</mi></msubsup><mi>d</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐱</mi><mi>k</mi></msub><mo>,</mo><msub><mi>𝐱</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">\begin{equation}
\sum_{j=1}^n{u_{ij}^md(\mathbf{x}_k,\mathbf{x}_j)}
\end{equation}</annotation></semantics></math> Note that, because the
medoid is a point chosen among the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
input objects, we do not need to calculate its coordinates (although see
explanation below for centroids), moreover, the distance between a
medoid and the other objects (step #2 in the alternate optimization
algorithm) will be readily available from the beginning, so it does not
need to be computed. All this makes dealing with medoids computationally
much faster than dealing with centroids.</p>
</div>
<div class="section level4">
<h4 id="partitive-clustering">Partitive clustering<a class="anchor" aria-label="anchor" href="#partitive-clustering"></a>
</h4>
<p>A clustering method is called <em>partitive</em> if object
memberships (crisp or fuzzy) are constrained to sum to one for each
object:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>c</mi></munderover><msub><mi>u</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\begin{equation}\label{eq:partition}
\sum_{i=1}^c{u_{ij}}=1
\end{equation}</annotation></semantics></math> This constrain is usually
referred to as the <em>partition restriction</em>. It ensures that all
objects will be classified as either belonging to a single cluster or
dividing their membership among different clusters. No objects will be
left unclassified.</p>
<p>K-means (KM, also known as hard c-means) <span class="citation">(MacQueen 1967)</span> and Fuzzy c-means (FCM) <span class="citation">(Bezdek 1981)</span> are two, centroid-based, partitive
clustering algorithms widely used in many unsupervised pattern
recognition applications. The main difference between the two methods is
that in KM every object belongs to a single cluster (i.e clusters are
`hard’) whereas in FCM the memberships are fuzzy and a given object may
have some degree of membership to more than one cluster.</p>
<p>Cluster memberships (step #3) are determined in KM simply by
<em>assigning each object to the cluster whose centroid is closest</em>.
In the case of FCM, fuzzy memberships are calculated using the following
formula:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mrow><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mi>c</mi></munderover><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>/</mi><msub><mi>e</mi><mrow><mi>l</mi><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mn>2</mn><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\begin{equation}
u_{ij} = \frac{1}{\sum_{l=1}^c{(e_{ij}/e_{lj})^{2/(m-1)}}}
\end{equation}</annotation></semantics></math> As said above,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m&gt;1</annotation></semantics></math>
is the fuzziness coefficient. The smaller the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>,
the closer to a hard partition will be the result. If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>
is set too high and the data is noisy the resulting partition may be
completely fuzzy (i.e. where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mn>1</mn><mi>/</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">u_{ij}=1/c</annotation></semantics></math>
for all objects and clusters) and therefore uninformative.</p>
<p>As indicated above, KM and FCM are centroid-based, meaning they use
centroid-based crisp or fuzzy equations, respectively, for step #1. The
corresponding medoid-based methods are Hard C-medoids and Fuzzy
C-medoids, which instead use equations medoid-based crisp and fuzzy
equations, respectively <span class="citation">(Raghu Krishnapuram,
Joshi, and Yi 1999)</span>.</p>
</div>
<div class="section level4">
<h4 id="noise-clustering">Noise clustering<a class="anchor" aria-label="anchor" href="#noise-clustering"></a>
</h4>
<p>The noise clustering (NC) method <span class="citation">(R. N. Dave
1991)</span> is an attempt to make the FCM method more robust to the
effect of outliers. The rationale underlying NC is the following: if an
object is an outlier, this means that it lies far from all cluster
prototypes and, therefore, it should have low membership values to all
clusters. In order to achieve these low memberships, the NC considers an
additional class, called <em>Noise</em>. This class is not represented
by a ‘prototype’, like the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
‘true’ clusters. The effect of including the Noise class is that it
‘captures’ objects that are at a distances larger than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math>
from all the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
‘true’ prototypes. The NC membership function (step #3) for the ‘real’
clusters is:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>/</mi><mi>δ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mn>2</mn><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup><mo>+</mo><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mi>c</mi></munderover><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>/</mi><msub><mi>e</mi><mrow><mi>l</mi><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mn>2</mn><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\begin{equation}
u_{ij} = \frac{1}{(e_{ij}/\delta)^{2/(m-1)}+\sum_{l=1}^c{(e_{ij}/e_{lj})^{2/(m-1)}}}
\end{equation}</annotation></semantics></math> whereas the fuzzy
membership to the Noise class,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>u</mi><mrow><mi>N</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">u_{Nj}</annotation></semantics></math>,
is one minus the sum of memberships to the real clusters.
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mrow><mi>N</mi><mi>j</mi></mrow></msub><mo>=</mo><mn>1</mn><mo>−</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>c</mi></munderover><msub><mi>u</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\begin{equation}
u_{Nj} = 1 - \sum_{i=1}^c{u_{ij}}
\end{equation}</annotation></semantics></math> Outlier objects have
small membership values to the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
real clusters because the first term in the denominator of the noise
membership equation is large. The smaller the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math>,
the higher the memberships to the Noise class will be. In contrast,
large values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math>
make NC equivalent to FCM. In NC, the fuzziness exponent
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>
has the same interpretation as in FCM. Including the Noise class has the
effect of relaxing the partition restriction. In NC, the partition
restriction is fulfilled when all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
real clusters and the Noise class are considered.</p>
<p>Note that, like FCM and KM, we can define a ‘hard’ counterpart of the
(fuzzy) noise clustering method. Indeed, the hard noise clustering (HNC)
method differs from the fuzzy one in that memberships are not fuzzy.
Like KM, its membership function can be described verbally. One assigns
the object to the noise class if the distances to all cluster centroids
is larger than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math>.
Otherwise, one assigns the object to the cluster whose centroid is
closest, as in KM.</p>
<p>The noise clustering method was originally defined with centroids as
prototypes. However, either hard or fuzzy noise clustering can be
applied to medoids instead of centroids. Although we have found no
references exploring this approach, the corresponding algorithms could
be named ‘hard noise clustering with medoids’ (HNCdd) and ‘(fuzzy) noise
clustering with medoids’ (NCdd).</p>
</div>
<div class="section level4">
<h4 id="possibilistic-clustering">Possibilistic clustering<a class="anchor" aria-label="anchor" href="#possibilistic-clustering"></a>
</h4>
<p>Possibilistic C-means <span class="citation">(R. Krishnapuram and
Keller 1993, 1996)</span> is another modification of FCM seeking
increased cluster robustness. The partition restriction is eliminated in
PCM, which produces
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
independent fuzzy clusters, each corresponding to a dense region of
points. Whereas the FCM and NC membership functions compare the distance
from the object to the cluster of interest,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">e_{ij}</annotation></semantics></math>,
with the distances to the remaining prototypes (and to the noise class
in the case of NC), in PCM the membership value for a given object to a
cluster does not depend on the distances to the remaining cluster
prototypes. Instead, the distance to the cluster of interest is compared
to a reference distance
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\eta_i</annotation></semantics></math>):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow><mn>2</mn></msubsup><mi>/</mi><msub><mi>η</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mn>1</mn><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\begin{equation}
u_{ij} = \frac{1}{1+(e^2_{ij}/\eta_i)^{1/(m-1)}}
\end{equation}</annotation></semantics></math> The reference distance is
a parameter that must be provided for each cluster. All objects whose
distance to the cluster center is smaller than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\eta_i</annotation></semantics></math>
will obtain a membership value higher than 0.5.</p>
<p>The fact that the membership to a given cluster does not depend on
the distances to the remaining cluster prototypes entails that cluster
repulsion is eliminated in PCM, with the consequence that samples can
have high membership to different clusters. Good estimation of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\eta_i</annotation></semantics></math>
is crucial for the success of the PCM method <span class="citation">(De
Cáceres, Oliva, and Font 2006)</span>. Inadequate initialization of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\eta_i</annotation></semantics></math>
can lead to a loss of cluster structures, even with the correct
partition as initial starting configuration. A single PCM run can be
regarded as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
independent runs of NC, each looking for a single cluster and where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>δ</mi><mi>i</mi><mn>2</mn></msubsup><mo>=</mo><msub><mi>η</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\delta_i^2=\eta_i</annotation></semantics></math><span class="citation">(R. N. Dave and Krishnapuram 1997)</span>. In
vegetation data plant communities with intermediate characteristics are
frequent. This fact makes the PCM method impractical for classification
of vegetation, because without cluster repulsion PCM clusters are
frequently highly mobile and converge to the same cluster, leaving large
parts of the data unassigned <span class="citation">(De Cáceres, Font,
and Oliva 2010)</span>.</p>
</div>
</div>
<div class="section level3">
<h3 id="dissimilarity-based-duals">Dissimilarity-based duals<a class="anchor" aria-label="anchor" href="#dissimilarity-based-duals"></a>
</h3>
<p>All the clustering methods presented above can be executed on a
resemblance space described using either
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐗</mi><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>.
The latter case avoids explicitly dealing with coordinates when creating
groups.</p>
<div class="section level4">
<h4 id="medoid-based-clustering-and-dissimilarity-matrices">Medoid-based clustering and dissimilarity matrices<a class="anchor" aria-label="anchor" href="#medoid-based-clustering-and-dissimilarity-matrices"></a>
</h4>
<p>Because medoids are selected among the objects to be classified it is
obvious that the distance to the cluster prototypes,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">e_{ij}</annotation></semantics></math>,
can be drawn from a symmetric matrix of pairwise distances between
objects calculated before the alternate optimization algorithm is
initiated. In other words, one can conduct medoid-based clustering on a
site-by-site distance matrix instead of using a site-by-species
rectangular matrix. Moreover, one can straightforwardly skip the use of
Euclidean distance and use a dissimilarity measure more appropriate for
ecological data.</p>
</div>
<div class="section level4">
<h4 id="centroid-based-clustering-and-dissimilarity-matrices">Centroid-based clustering and dissimilarity matrices<a class="anchor" aria-label="anchor" href="#centroid-based-clustering-and-dissimilarity-matrices"></a>
</h4>
<p>When dealing with centroids, it may seem unavoidable to calculate
centroid coordinates (step S.1) before calculating the (squared)
Euclidean distances to cluster centers
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">e_{ij}</annotation></semantics></math>
(step S.2):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow><mn>2</mn></msubsup><mo>=</mo><mo stretchy="false" form="postfix">∥</mo><msub><mi>𝐜</mi><mi>i</mi></msub><mo>−</mo><msub><mi>𝐱</mi><mi>j</mi></msub><msup><mo stretchy="false" form="postfix">∥</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\begin{equation}
e_{ij}^2 = \| \mathbf{c}_i-\mathbf{x}_j \|^2
\end{equation}</annotation></semantics></math> However, there is a
mathematical trick that avoids the need to calculate the coordinates
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐜</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathbf{c}_i</annotation></semantics></math>
explictly. Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>
be the matrix of Euclidean distances between pairs of objects. We can
obtain
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow><mn>2</mn></msubsup><annotation encoding="application/x-tex">e_{ij}^2</annotation></semantics></math>
as follows:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow><mn>2</mn></msubsup><mo>=</mo><mfrac><mn>1</mn><msub><mi>n</mi><mi>i</mi></msub></mfrac><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>i</mi></msub></munderover><msubsup><mi>d</mi><mrow><mi>l</mi><mi>j</mi></mrow><mn>2</mn></msubsup><mo>−</mo><mfrac><mn>1</mn><mrow><mn>2</mn><msubsup><mi>n</mi><mi>i</mi><mn>2</mn></msubsup></mrow></mfrac><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>i</mi></msub></munderover><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>i</mi></msub></munderover><msubsup><mi>d</mi><mrow><mi>l</mi><mi>k</mi></mrow><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\begin{equation}
e_{ij}^2 = \frac{1}{n_i}\sum_{l=1}^{n_i}{d_{lj}^2}- \frac{1}{2n_i^2}\sum_{k=1}^{n_i}\sum_{l=1}^{n_i}{d_{lk}^2}
\end{equation}</annotation></semantics></math> The left part of this
equation is a sum of squared distances from the target object to all the
other objects in the cluster. The right part of the equation is an
average of squared distances between objects in the cluster.
Distance-based
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow><mn>2</mn></msubsup><annotation encoding="application/x-tex">e_{ij}^2</annotation></semantics></math>
equation can be generalized to the case of a fuzzy cluster:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow><mn>2</mn></msubsup><mo>=</mo><mfrac><mn>1</mn><mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msubsup><mi>u</mi><mrow><mi>i</mi><mi>k</mi></mrow><mi>m</mi></msubsup></mrow></mfrac><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>i</mi></msub></munderover><msubsup><mi>d</mi><mrow><mi>l</mi><mi>j</mi></mrow><mn>2</mn></msubsup><mo>−</mo><mfrac><mn>1</mn><mrow><mn>2</mn><msup><mrow><mo stretchy="true" form="prefix">(</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msubsup><mi>u</mi><mrow><mi>i</mi><mi>k</mi></mrow><mi>m</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow></mfrac><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><msubsup><mi>u</mi><mrow><mi>i</mi><mi>k</mi></mrow><mi>m</mi></msubsup><msubsup><mi>u</mi><mrow><mi>i</mi><mi>l</mi></mrow><mi>m</mi></msubsup><msubsup><mi>d</mi><mrow><mi>l</mi><mi>k</mi></mrow><mn>2</mn></msubsup></mrow></mrow><annotation encoding="application/x-tex">\begin{equation}
e_{ij}^2 = \frac{1}{\sum_{k=1}^n{u_{ik}^m}}\sum_{l=1}^{n_i}{d_{lj}^2}- \frac{1}{2\left(\sum_{k=1}^n{u_{ik}^m}\right)^2}\sum_{k=1}^{n}\sum_{l=1}^{n}{u_{ik}^mu_{il}^md_{lk}^2}
\end{equation}</annotation></semantics></math> Crisp and fuzzy
distance-based equations allow the Euclidean distance to a centroid to
be determined without calculating its coordinates. Therefore, they allow
steps #1 and #2 to be combined into a single step. In other words,
distance-based duals exist for centroid-based clustering methods when
the resemblance space comprises Euclidean distances <span class="citation">(R. J. Hathaway, Davenport, and Bezdek 1989; R.
Hathaway, Bezdek, and Davenport 1996)</span>.</p>
<p>If we transform the original data in order to emulate a distance
(like the chord), then the duality holds, although centroids are defined
in the transformed space. What happens if the values in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>
were not calculated using the Euclidean distance? Crisp and fuzzy
distance-based equations are also valid for other dissimilarity
measures, although there are important details to be remembered. These
equations assume that the resemblance space is Euclidean (i.e. does not
produce negative eigenvalues in principal coordinates analysis) and that
centroids are appropriate prototypes for clusters. If the
dissimilarities do not have the Euclidean property some oddities may
arise <span class="citation">(R. J. Hathaway and Bezdek 1994)</span>.
For example, it is possible to obtain negative
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow><mn>2</mn></msubsup><annotation encoding="application/x-tex">e_{ij}^2</annotation></semantics></math>
values, specially for groups of small size. In practice, however, when
these negative distances occur they can be reset to zero <span class="citation">(De Cáceres, Oliva, and Font 2006)</span>.</p>
</div>
</div>
</div>
<div class="section level2">
<h2 id="managing-vegetation-classifications">Managing vegetation classifications<a class="anchor" aria-label="anchor" href="#managing-vegetation-classifications"></a>
</h2>
<div class="section level3">
<h3 id="creating-classifications-vegclust-and-vegclustdist">Creating classifications: <code>vegclust</code> and
<code>vegclustdist()</code><a class="anchor" aria-label="anchor" href="#creating-classifications-vegclust-and-vegclustdist"></a>
</h3>
<p>Functions <code>vegclust</code> and <code><a href="../reference/vegclust.html">vegclustdist()</a></code> allow
vegetation types to be defined from a set of unlabelled vegetation
observations (i.e. relevés or plot records) using any of the clustering
models explained in the previous section. <code>vegclust</code> requires
a rectangular site-by-species matrix, whereas
<code><a href="../reference/vegclust.html">vegclustdist()</a></code> requires a symmetric site-by-site
dissimilarity matrix.</p>
<div class="section level4">
<h4 id="the-k-means-model">The K-means model<a class="anchor" aria-label="anchor" href="#the-k-means-model"></a>
</h4>
<p>The following piece of code produces a classification of our example
data set into three groups using the K-means clustering model:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetland.km</span> <span class="op">=</span> <span class="fu"><a href="../reference/vegclust.html">vegclust</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">wetlandchord</span>, mobileCenters<span class="op">=</span><span class="fl">3</span>, </span>
<span>                      method<span class="op">=</span><span class="st">"KM"</span>, nstart<span class="op">=</span><span class="fl">20</span><span class="op">)</span></span></code></pre></div>
<p>The result is an object of class <code>vegclust</code>, in fact a
list with several components (method, parameters, prototypes, objective
function, etc.):</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">wetland.km</span><span class="op">)</span></span>
<span><span class="co">#&gt;  [1] "mode"          "method"        "m"             "dnoise"       </span></span>
<span><span class="co">#&gt;  [5] "eta"           "memb"          "mobileCenters" "fixedCenters" </span></span>
<span><span class="co">#&gt;  [9] "dist2clusters" "withinss"      "size"          "functional"   </span></span>
<span><span class="co">#&gt; [13] "iter"</span></span></code></pre></div>
<p>One of the most important components is the membership matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐔</mi><annotation encoding="application/x-tex">\mathbf{U}</annotation></semantics></math>,
which we show transposed here:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">wetland.km</span><span class="op">$</span><span class="va">memb</span><span class="op">)</span></span>
<span><span class="co">#&gt;    5 8 13 4 17 3 9 21 16 14 2 15 1 7 10 40 23 25 22 20 6 18 12 39 19 11 30 34</span></span>
<span><span class="co">#&gt; M1 0 0  0 0  0 0 0  0  0  0 0  0 0 0  0  1  1  1  1  1 1  1  1  1  1  1  0  0</span></span>
<span><span class="co">#&gt; M2 0 0  0 0  0 0 0  0  0  0 0  0 0 0  0  0  0  0  0  0 0  0  0  0  0  0  1  1</span></span>
<span><span class="co">#&gt; M3 1 1  1 1  1 1 1  1  1  1 1  1 1 1  1  0  0  0  0  0 0  0  0  0  0  0  0  0</span></span>
<span><span class="co">#&gt;    28 31 26 29 33 24 36 37 41 27 32 35 38</span></span>
<span><span class="co">#&gt; M1  0  0  1  1  1  0  0  0  0  0  0  0  0</span></span>
<span><span class="co">#&gt; M2  1  1  0  0  0  1  1  1  1  1  1  0  0</span></span>
<span><span class="co">#&gt; M3  0  0  0  0  0  0  0  0  0  0  0  1  1</span></span></code></pre></div>
<p>Another important component is the matrix containing the coordinates
of cluster centroids (i.e. vectors
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐜</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mathbf{c}_i</annotation></semantics></math>
for each cluster):</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="va">wetland.km</span><span class="op">$</span><span class="va">mobileCenters</span>, dig<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#&gt;    Abefic Merhed Alyvag Pancam Abemos Melcor Ludoct Eupvac Echpas Passcr Poa2</span></span>
<span><span class="co">#&gt; M1  0.000  0.000  0.047  0.076  0.016  0.153  0.000  0.050  0.066  0.000 0.01</span></span>
<span><span class="co">#&gt; M2  0.018  0.068  0.000  0.356  0.015  0.275  0.019  0.205  0.102  0.026 0.00</span></span>
<span><span class="co">#&gt; M3  0.000  0.000  0.000  0.027  0.000  0.062  0.000  0.039  0.048  0.000 0.00</span></span>
<span><span class="co">#&gt;    Carhal Dendio Casobt Aesind Cyprot Ipocop Cynarc Walind Sessp. Phynod Echell</span></span>
<span><span class="co">#&gt; M1  0.069  0.000  0.000  0.075  0.081  0.013  0.013  0.064  0.104  0.715  0.119</span></span>
<span><span class="co">#&gt; M2  0.000  0.000  0.000  0.019  0.176  0.040  0.432  0.078  0.157  0.064  0.112</span></span>
<span><span class="co">#&gt; M3  0.037  0.016  0.016  0.000  0.000  0.000  0.000  0.068  0.144  0.000  0.049</span></span>
<span><span class="co">#&gt;    Helind Ipoaqu Orysp. Elesp. Psespi Ludads Polatt  Poa1 Helcri Physp. Goopur</span></span>
<span><span class="co">#&gt; M1  0.172  0.048  0.172  0.138  0.027  0.000  0.000 0.013  0.013  0.000  0.000</span></span>
<span><span class="co">#&gt; M2  0.019  0.037  0.040  0.000  0.000  0.000  0.000 0.000  0.000  0.000  0.000</span></span>
<span><span class="co">#&gt; M3  0.125  0.055  0.649  0.154  0.192  0.204  0.097 0.000  0.000  0.012  0.012</span></span></code></pre></div>
<p>The same classification exercise can be conducted from the matrix of
chord distances between objects if we use function
<code><a href="../reference/vegclust.html">vegclustdist()</a></code> instead of <code>vegclust</code>:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetland.kmdist</span> <span class="op">=</span> <span class="fu"><a href="../reference/vegclust.html">vegclustdist</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">dchord</span>, mobileMemb<span class="op">=</span><span class="fl">3</span>, </span>
<span>                              method<span class="op">=</span><span class="st">"KM"</span>, nstart <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">wetland.kmdist</span><span class="op">)</span></span>
<span><span class="co">#&gt;  [1] "mode"          "method"        "m"             "dnoise"       </span></span>
<span><span class="co">#&gt;  [5] "eta"           "memb"          "mobileCenters" "fixedCenters" </span></span>
<span><span class="co">#&gt;  [9] "dist2clusters" "withinss"      "size"          "functional"</span></span></code></pre></div>
<p>Note the different way to specify the number of clusters. In the case
of <code><a href="../reference/vegclust.html">vegclustdist()</a></code> we do not obtain cluster centroids,
because they cannot be calculated explicitly:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetland.kmdist</span><span class="op">$</span><span class="va">mobileCenters</span></span>
<span><span class="co">#&gt; NULL</span></span></code></pre></div>
<p>But we do obtain cluster memberships:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">wetland.kmdist</span><span class="op">$</span><span class="va">memb</span><span class="op">)</span></span>
<span><span class="co">#&gt;    5 8 13 4 17 3 9 21 16 14 2 15 1 7 10 40 23 25 22 20 6 18 12 39 19 11 30 34</span></span>
<span><span class="co">#&gt; M1 0 0  0 0  0 0 0  0  0  0 0  0 0 0  0  0  0  0  0  0 0  0  0  0  0  0  1  1</span></span>
<span><span class="co">#&gt; M2 0 0  0 0  0 0 0  0  0  0 0  0 0 0  0  1  1  1  1  1 1  1  1  1  1  1  0  0</span></span>
<span><span class="co">#&gt; M3 1 1  1 1  1 1 1  1  1  1 1  1 1 1  1  0  0  0  0  0 0  0  0  0  0  0  0  0</span></span>
<span><span class="co">#&gt;    28 31 26 29 33 24 36 37 41 27 32 35 38</span></span>
<span><span class="co">#&gt; M1  1  1  0  0  0  1  1  1  1  1  1  0  0</span></span>
<span><span class="co">#&gt; M2  0  0  1  1  1  0  0  0  0  0  0  0  0</span></span>
<span><span class="co">#&gt; M3  0  0  0  0  0  0  0  0  0  0  0  1  1</span></span></code></pre></div>
<p>Because we used the same resemblance space (although in different
form) in our examples, both <code>vegclust</code> and
<code><a href="../reference/vegclust.html">vegclustdist()</a></code> should give the same result provided the
algorithm has not become stuck in a relative optimum of the objective
function. Although both R functions return objects of class
<code>vegclust</code>, we can identify whether calculations were done
from dissimilarities or from rectangular matrices by inspecting the
‘mode’ element of the list:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetland.km</span><span class="op">$</span><span class="va">mode</span></span>
<span><span class="co">#&gt; [1] "raw"</span></span>
<span><span class="va">wetland.kmdist</span><span class="op">$</span><span class="va">mode</span></span>
<span><span class="co">#&gt; [1] "dist"</span></span></code></pre></div>
<p>In the following subsections we run <code>vegclust</code> using other
clustering models, but the same examples could be made using
<code><a href="../reference/vegclust.html">vegclustdist()</a></code>.</p>
</div>
<div class="section level4">
<h4 id="the-fuzzy-c-means-model">The Fuzzy C-means model<a class="anchor" aria-label="anchor" href="#the-fuzzy-c-means-model"></a>
</h4>
<p>Let us inspect the distance of each object to each cluster
centroid:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">wetland.km</span><span class="op">$</span><span class="va">dist2clusters</span><span class="op">)</span>, dig<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span>
<span><span class="co">#&gt;       5    8   13    4   17    3    9   21   16   14    2   15    1    7   10</span></span>
<span><span class="co">#&gt; M1 1.05 1.10 1.09 1.14 1.11 1.22 1.23 1.09 1.09 1.10 1.12 1.19 1.12 1.15 1.19</span></span>
<span><span class="co">#&gt; M2 1.12 1.12 1.14 1.17 1.07 1.22 1.22 1.20 1.17 1.16 1.17 1.21 1.21 1.18 1.23</span></span>
<span><span class="co">#&gt; M3 0.54 0.68 0.44 0.45 0.64 0.76 0.95 0.50 0.64 0.46 0.38 0.57 0.47 0.72 0.87</span></span>
<span><span class="co">#&gt;      40   23   25   22   20    6   18   12   39   19   11   30   34   28   31</span></span>
<span><span class="co">#&gt; M1 0.40 0.60 0.51 0.67 0.56 0.47 0.45 0.40 0.52 0.44 0.64 1.16 1.20 1.15 1.19</span></span>
<span><span class="co">#&gt; M2 1.09 1.07 1.12 1.03 1.15 1.06 1.12 1.12 1.06 1.07 1.07 0.86 0.66 0.77 0.69</span></span>
<span><span class="co">#&gt; M3 1.11 0.92 0.86 0.73 1.11 1.15 1.19 1.16 1.12 0.97 1.13 1.20 1.22 1.19 1.20</span></span>
<span><span class="co">#&gt;      26   29   33   24   36   37   41   27   32   35   38</span></span>
<span><span class="co">#&gt; M1 0.81 0.78 0.49 1.04 0.90 1.15 1.14 1.19 1.13 1.03 1.10</span></span>
<span><span class="co">#&gt; M2 1.00 0.92 1.00 0.55 0.62 0.55 0.56 0.78 0.73 0.95 0.99</span></span>
<span><span class="co">#&gt; M3 1.22 1.17 1.22 1.20 1.18 1.17 0.99 1.22 1.17 0.80 0.68</span></span></code></pre></div>
<p>For many objects the distance to the cluster where they have been
assigned is much smaller than the distance to other clusters. However,
for some objects (such as ‘22’, ‘29’ or ‘35’) the distance to the
closest cluster center does not differ much from the distance to second
closest one. Are those latter objects well assigned? Should these
objects have intermediate degrees of membership instead of picking one
cluster arbitrarily? The Fuzzy C-means cluster model allows fuzzy
memberships to be obtained as an alternative to crisp memberships:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetland.fcm</span> <span class="op">=</span> <span class="fu"><a href="../reference/vegclust.html">vegclust</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">wetlandchord</span>, mobileCenters<span class="op">=</span><span class="fl">3</span>, </span>
<span>                       method<span class="op">=</span><span class="st">"FCM"</span>, m<span class="op">=</span><span class="fl">1.2</span>, nstart<span class="op">=</span><span class="fl">20</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">wetland.fcm</span><span class="op">$</span><span class="va">memb</span><span class="op">)</span>, dig<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#&gt;        5     8 13 4    17     3     9 21    16 14 2    15 1     7    10 40</span></span>
<span><span class="co">#&gt; M1 0.998 0.985  1 1 0.990 0.981 0.844  1 0.993  1 1 0.999 1 0.981 0.920  0</span></span>
<span><span class="co">#&gt; M2 0.001 0.007  0 0 0.004 0.009 0.070  0 0.004  0 0 0.001 0 0.011 0.044  1</span></span>
<span><span class="co">#&gt; M3 0.001 0.007  0 0 0.007 0.011 0.086  0 0.003  0 0 0.001 0 0.009 0.036  0</span></span>
<span><span class="co">#&gt;       23    25    22    20 6 18 12    39 19    11    30    34    28    31    26</span></span>
<span><span class="co">#&gt; M1 0.016 0.007 0.404 0.001 0  0  0 0.000  0 0.003 0.031 0.002 0.013 0.003 0.017</span></span>
<span><span class="co">#&gt; M2 0.980 0.992 0.582 0.998 1  1  1 0.999  1 0.992 0.040 0.002 0.016 0.003 0.841</span></span>
<span><span class="co">#&gt; M3 0.004 0.001 0.014 0.001 0  0  0 0.001  0 0.005 0.928 0.996 0.971 0.993 0.141</span></span>
<span><span class="co">#&gt;       29    33    24    36    37    41    27    32    35    38</span></span>
<span><span class="co">#&gt; M1 0.017 0.000 0.000 0.001 0.001 0.004 0.012 0.008 0.783 0.970</span></span>
<span><span class="co">#&gt; M2 0.742 0.999 0.002 0.020 0.001 0.001 0.015 0.011 0.057 0.006</span></span>
<span><span class="co">#&gt; M3 0.241 0.001 0.998 0.978 0.999 0.995 0.973 0.980 0.160 0.024</span></span></code></pre></div>
<p>A comparison of these memberships with the distance to the clusters
shown before will reveal that intermediate objects obtain fuzzier
membership values than other objects.</p>
<p>Although FCM is theoretically a better model than KM for vegetation
classification, vegetation scientists are normally interested in crisp
assignments. The function <code><a href="../reference/defuzzify.html">defuzzify()</a></code> allows fuzzy
membership matrix to be converted into a crisp one:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">groups</span> <span class="op">=</span> <span class="fu"><a href="../reference/defuzzify.html">defuzzify</a></span><span class="op">(</span><span class="va">wetland.fcm</span><span class="op">)</span><span class="op">$</span><span class="va">cluster</span></span>
<span><span class="va">groups</span></span>
<span><span class="co">#&gt;    5    8   13    4   17    3    9   21   16   14    2   15    1    7   10   40 </span></span>
<span><span class="co">#&gt; "M1" "M1" "M1" "M1" "M1" "M1" "M1" "M1" "M1" "M1" "M1" "M1" "M1" "M1" "M1" "M2" </span></span>
<span><span class="co">#&gt;   23   25   22   20    6   18   12   39   19   11   30   34   28   31   26   29 </span></span>
<span><span class="co">#&gt; "M2" "M2" "M2" "M2" "M2" "M2" "M2" "M2" "M2" "M2" "M3" "M3" "M3" "M3" "M2" "M2" </span></span>
<span><span class="co">#&gt;   33   24   36   37   41   27   32   35   38 </span></span>
<span><span class="co">#&gt; "M2" "M3" "M3" "M3" "M3" "M3" "M3" "M1" "M1"</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">groups</span><span class="op">)</span></span>
<span><span class="co">#&gt; groups</span></span>
<span><span class="co">#&gt; M1 M2 M3 </span></span>
<span><span class="co">#&gt; 17 14 10</span></span></code></pre></div>
<p>Another way of defuzzifying the membership matrix is by setting a
threshold of minimum fuzzy membership:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">groups</span> <span class="op">=</span> <span class="fu"><a href="../reference/defuzzify.html">defuzzify</a></span><span class="op">(</span><span class="va">wetland.fcm</span>, method <span class="op">=</span> <span class="st">"cut"</span>, alpha <span class="op">=</span> <span class="fl">0.8</span><span class="op">)</span><span class="op">$</span><span class="va">cluster</span></span>
<span><span class="va">groups</span></span>
<span><span class="co">#&gt;    5    8   13    4   17    3    9   21   16   14    2   15    1    7   10   40 </span></span>
<span><span class="co">#&gt; "M1" "M1" "M1" "M1" "M1" "M1" "M1" "M1" "M1" "M1" "M1" "M1" "M1" "M1" "M1" "M2" </span></span>
<span><span class="co">#&gt;   23   25   22   20    6   18   12   39   19   11   30   34   28   31   26   29 </span></span>
<span><span class="co">#&gt; "M2" "M2"   NA "M2" "M2" "M2" "M2" "M2" "M2" "M2" "M3" "M3" "M3" "M3" "M2"   NA </span></span>
<span><span class="co">#&gt;   33   24   36   37   41   27   32   35   38 </span></span>
<span><span class="co">#&gt; "M2" "M3" "M3" "M3" "M3" "M3" "M3"   NA "M1"</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">groups</span>, useNA <span class="op">=</span> <span class="st">"always"</span><span class="op">)</span></span>
<span><span class="co">#&gt; groups</span></span>
<span><span class="co">#&gt;   M1   M2   M3 &lt;NA&gt; </span></span>
<span><span class="co">#&gt;   16   12   10    3</span></span></code></pre></div>
<p>With this second defuzzification approach intermediate objects remain
unclassified (indicated as missing values). It is important to recognise
that FCM fuzzy membership values depend on the fuzziness exponent
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>.
In fact, if we run FCM with a very large
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>
value we will obtain uninformative results:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetland.fcm2</span> <span class="op">=</span> <span class="fu"><a href="../reference/vegclust.html">vegclust</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">wetlandchord</span>, mobileCenters<span class="op">=</span><span class="fl">3</span>, </span>
<span>                       method<span class="op">=</span><span class="st">"FCM"</span>, m<span class="op">=</span><span class="fl">10</span>, nstart<span class="op">=</span><span class="fl">20</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">wetland.fcm2</span><span class="op">$</span><span class="va">memb</span><span class="op">)</span>, dig<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#&gt;        5     8    13     4    17     3     9    21    16    14     2    15</span></span>
<span><span class="co">#&gt; M1 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333</span></span>
<span><span class="co">#&gt; M2 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333</span></span>
<span><span class="co">#&gt; M3 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333</span></span>
<span><span class="co">#&gt;        1     7    10    40    23    25    22    20     6    18    12    39</span></span>
<span><span class="co">#&gt; M1 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333</span></span>
<span><span class="co">#&gt; M2 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333</span></span>
<span><span class="co">#&gt; M3 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333</span></span>
<span><span class="co">#&gt;       19    11    30    34    28    31    26    29    33    24    36    37</span></span>
<span><span class="co">#&gt; M1 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333</span></span>
<span><span class="co">#&gt; M2 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333</span></span>
<span><span class="co">#&gt; M3 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333 0.333</span></span>
<span><span class="co">#&gt;       41    27    32    35    38</span></span>
<span><span class="co">#&gt; M1 0.333 0.333 0.333 0.333 0.333</span></span>
<span><span class="co">#&gt; M2 0.333 0.333 0.333 0.333 0.333</span></span>
<span><span class="co">#&gt; M3 0.333 0.333 0.333 0.333 0.333</span></span></code></pre></div>
<p>These uninformative results become obvious after defuzzification of
the membership matrix:</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">groups2</span> <span class="op">=</span> <span class="fu"><a href="../reference/defuzzify.html">defuzzify</a></span><span class="op">(</span><span class="va">wetland.fcm2</span>, method <span class="op">=</span> <span class="st">"cut"</span>, alpha <span class="op">=</span> <span class="fl">0.8</span><span class="op">)</span><span class="op">$</span><span class="va">cluster</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">groups2</span>, useNA <span class="op">=</span> <span class="st">"always"</span><span class="op">)</span></span>
<span><span class="co">#&gt; groups2</span></span>
<span><span class="co">#&gt; &lt;NA&gt; </span></span>
<span><span class="co">#&gt;   41</span></span></code></pre></div>
</div>
<div class="section level4">
<h4 id="the-noise-clustering-model">The Noise clustering model<a class="anchor" aria-label="anchor" href="#the-noise-clustering-model"></a>
</h4>
<p>In the previous two models, all objects were assigned, either
completely to one cluster or with their membership divided among
clusters (in other words, we accepted the partition restriction). This
may be appropriate in many instances, but it may cause problems if some
of the plant communities sampled include rare species assemblages. These
plant communities would more appropriately be classified as ‘outliers’
and should not influence the cluster prototypes. In the noise clustering
(NC) model we allow outlier objects to be excluded from the
classification:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetland.nc</span> <span class="op">=</span> <span class="fu"><a href="../reference/vegclust.html">vegclust</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">wetlandchord</span>, mobileCenters<span class="op">=</span><span class="fl">3</span>,</span>
<span>                       method<span class="op">=</span><span class="st">"NC"</span>, m<span class="op">=</span><span class="fl">1.2</span>, dnoise<span class="op">=</span><span class="fl">0.8</span>, nstart<span class="op">=</span><span class="fl">20</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">wetland.nc</span><span class="op">$</span><span class="va">memb</span><span class="op">)</span>, dig<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span>
<span><span class="co">#&gt;       5    8 13 4   17    3    9 21   16   14 2   15 1    7   10 40   23   25</span></span>
<span><span class="co">#&gt; M1 0.00 0.00  0 0 0.00 0.01 0.01  0 0.00 0.00 0 0.00 0 0.01 0.01  0 0.00 0.00</span></span>
<span><span class="co">#&gt; M2 0.99 0.85  1 1 0.93 0.41 0.08  1 0.86 0.99 1 0.93 1 0.49 0.12  0 0.01 0.01</span></span>
<span><span class="co">#&gt; M3 0.00 0.00  0 0 0.00 0.01 0.01  0 0.00 0.00 0 0.00 0 0.01 0.01  1 0.93 0.98</span></span>
<span><span class="co">#&gt; N  0.01 0.14  0 0 0.07 0.58 0.90  0 0.13 0.01 0 0.07 0 0.49 0.86  0 0.06 0.01</span></span>
<span><span class="co">#&gt;      22   20 6 18 12   39 19   11   30   34   28   31   26   29   33 24 36 37</span></span>
<span><span class="co">#&gt; M1 0.00 0.00 0  0  0 0.00  0 0.00 0.07 0.98 0.08 0.98 0.03 0.08 0.00  1  1  1</span></span>
<span><span class="co">#&gt; M2 0.50 0.00 0  0  0 0.00  0 0.00 0.01 0.00 0.01 0.00 0.01 0.01 0.00  0  0  0</span></span>
<span><span class="co">#&gt; M3 0.39 0.98 1  1  1 0.99  1 0.93 0.01 0.00 0.02 0.00 0.28 0.34 0.99  0  0  0</span></span>
<span><span class="co">#&gt; N  0.11 0.02 0  0  0 0.01  0 0.06 0.90 0.02 0.89 0.02 0.68 0.58 0.01  0  0  0</span></span>
<span><span class="co">#&gt;      41   27   32   35   38</span></span>
<span><span class="co">#&gt; M1 0.93 0.05 0.11 0.02 0.00</span></span>
<span><span class="co">#&gt; M2 0.01 0.01 0.01 0.48 0.90</span></span>
<span><span class="co">#&gt; M3 0.00 0.01 0.02 0.03 0.00</span></span>
<span><span class="co">#&gt; N  0.06 0.92 0.85 0.47 0.09</span></span></code></pre></div>
<p>As with FCM, some objects have intermediate memberships. In addition,
there are some objects with high membership to the Noise class, which
indicates that they are distant from all ‘true’ cluster centers. These
objects can be considered ‘outliers’ and remain unclassified:</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">groups</span> <span class="op">=</span> <span class="fu"><a href="../reference/defuzzify.html">defuzzify</a></span><span class="op">(</span><span class="va">wetland.nc</span><span class="op">)</span><span class="op">$</span><span class="va">cluster</span></span>
<span><span class="va">groups</span></span>
<span><span class="co">#&gt;    5    8   13    4   17    3    9   21   16   14    2   15    1    7   10   40 </span></span>
<span><span class="co">#&gt; "M2" "M2" "M2" "M2" "M2"  "N"  "N" "M2" "M2" "M2" "M2" "M2" "M2"  "N"  "N" "M3" </span></span>
<span><span class="co">#&gt;   23   25   22   20    6   18   12   39   19   11   30   34   28   31   26   29 </span></span>
<span><span class="co">#&gt; "M3" "M3" "M2" "M3" "M3" "M3" "M3" "M3" "M3" "M3"  "N" "M1"  "N" "M1"  "N"  "N" </span></span>
<span><span class="co">#&gt;   33   24   36   37   41   27   32   35   38 </span></span>
<span><span class="co">#&gt; "M3" "M1" "M1" "M1" "M1"  "N"  "N" "M2" "M2"</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">groups</span><span class="op">)</span></span>
<span><span class="co">#&gt; groups</span></span>
<span><span class="co">#&gt; M1 M2 M3  N </span></span>
<span><span class="co">#&gt;  6 14 11 10</span></span></code></pre></div>
<p>Note that we can defuzzify the membership matrix using a threshold,
as before, and identify both intermediates (‘NA’) and outliers (members
of the noise class: `N’):</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">groups</span> <span class="op">=</span> <span class="fu"><a href="../reference/defuzzify.html">defuzzify</a></span><span class="op">(</span><span class="va">wetland.nc</span>, method<span class="op">=</span><span class="st">"cut"</span>, alpha<span class="op">=</span><span class="fl">0.8</span><span class="op">)</span><span class="op">$</span><span class="va">cluster</span></span>
<span><span class="va">groups</span></span>
<span><span class="co">#&gt;    5    8   13    4   17    3    9   21   16   14    2   15    1    7   10   40 </span></span>
<span><span class="co">#&gt; "M2" "M2" "M2" "M2" "M2"   NA  "N" "M2" "M2" "M2" "M2" "M2" "M2"   NA  "N" "M3" </span></span>
<span><span class="co">#&gt;   23   25   22   20    6   18   12   39   19   11   30   34   28   31   26   29 </span></span>
<span><span class="co">#&gt; "M3" "M3"   NA "M3" "M3" "M3" "M3" "M3" "M3" "M3"  "N" "M1"  "N" "M1"   NA   NA </span></span>
<span><span class="co">#&gt;   33   24   36   37   41   27   32   35   38 </span></span>
<span><span class="co">#&gt; "M3" "M1" "M1" "M1" "M1"  "N"  "N"   NA "M2"</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">groups</span>, useNA <span class="op">=</span> <span class="st">"always"</span><span class="op">)</span></span>
<span><span class="co">#&gt; groups</span></span>
<span><span class="co">#&gt;   M1   M2   M3    N &lt;NA&gt; </span></span>
<span><span class="co">#&gt;    6   12   11    6    6</span></span></code></pre></div>
<p>In vegetation classification, distinguishing between an intermediate
or an outlier will not always be clearcut. Nevertheless, the distinction
may be useful in practice because outlier objects may relate to
vegetation patterns that exist in the study area but happen to be
underrepresented in the sample. That is, outlier plant communities may
be rare for the given vegetation data set only, in the sense that if new
data were added they would belong to a vegetation type. Alternatively,
they may represent rare species assemblages for the study area.
Distinguishing between one case or the other cannot be done without
collecting more data <span class="citation">(Wiser and De Cáceres
2012)</span>.</p>
<p>An advantage of the NC model over FCM or KM is that ‘outliers’ do not
influence the cluster centers. As a result, the cluster centers are more
separated from each other than in the previous models. Compare the
following distance matrices between cluster centroids:</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/dist.html" class="external-link">dist</a></span><span class="op">(</span><span class="va">wetland.km</span><span class="op">$</span><span class="va">mobileCenters</span><span class="op">)</span></span>
<span><span class="co">#&gt;           M1        M2</span></span>
<span><span class="co">#&gt; M2 0.8997438          </span></span>
<span><span class="co">#&gt; M3 0.9248370 0.9567205</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/stats/dist.html" class="external-link">dist</a></span><span class="op">(</span><span class="va">wetland.fcm</span><span class="op">$</span><span class="va">mobileCenters</span><span class="op">)</span></span>
<span><span class="co">#&gt;           M1        M2</span></span>
<span><span class="co">#&gt; M2 0.9280498          </span></span>
<span><span class="co">#&gt; M3 0.9387465 0.8852144</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/stats/dist.html" class="external-link">dist</a></span><span class="op">(</span><span class="va">wetland.nc</span><span class="op">$</span><span class="va">mobileCenters</span><span class="op">)</span></span>
<span><span class="co">#&gt;           M1        M2</span></span>
<span><span class="co">#&gt; M2 1.0666331          </span></span>
<span><span class="co">#&gt; M3 1.0102841 0.9735451</span></span></code></pre></div>
<p>However, this particular advantage can also be obtained (in partitive
methods) if medoids are used as prototypes instead of centroids (see
below).</p>
</div>
<div class="section level4">
<h4 id="medoid-based-clustering">Medoid-based clustering<a class="anchor" aria-label="anchor" href="#medoid-based-clustering"></a>
</h4>
<p>All the examples that we have shown so far could be repeated using
medoids as cluster prototypes instead of centroids. For example, with
the K-medoids (the K-means analogue) would be:</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetland.kmdd</span> <span class="op">=</span> <span class="fu"><a href="../reference/vegclust.html">vegclust</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">wetlandchord</span>, mobileCenters<span class="op">=</span><span class="fl">3</span>, </span>
<span>                      method<span class="op">=</span><span class="st">"KMdd"</span>, nstart<span class="op">=</span><span class="fl">20</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">wetland.kmdd</span><span class="op">$</span><span class="va">memb</span><span class="op">)</span></span>
<span><span class="co">#&gt;    5 8 13 4 17 3 9 21 16 14 2 15 1 7 10 40 23 25 22 20 6 18 12 39 19 11 30 34</span></span>
<span><span class="co">#&gt; M1 0 0  0 0  0 0 0  0  0  0 0  0 0 0  0  0  0  0  0  0 0  0  0  0  0  0  1  1</span></span>
<span><span class="co">#&gt; M2 1 1  1 1  1 1 1  1  1  1 1  1 1 1  1  0  0  0  1  0 0  0  0  0  0  0  0  0</span></span>
<span><span class="co">#&gt; M3 0 0  0 0  0 0 0  0  0  0 0  0 0 0  0  1  1  1  0  1 1  1  1  1  1  1  0  0</span></span>
<span><span class="co">#&gt;    28 31 26 29 33 24 36 37 41 27 32 35 38</span></span>
<span><span class="co">#&gt; M1  1  1  0  0  0  1  1  1  1  1  1  0  0</span></span>
<span><span class="co">#&gt; M2  0  0  0  0  0  0  0  0  0  0  0  1  1</span></span>
<span><span class="co">#&gt; M3  0  0  1  1  1  0  0  0  0  0  0  0  0</span></span></code></pre></div>
<p>When ran using a site-by-species matrix as input,
<code><a href="../reference/vegclust.html">vegclust()</a></code> returns the coordinates of medoids as the
cluster centers:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="va">wetland.kmdd</span><span class="op">$</span><span class="va">mobileCenters</span>, dig<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#&gt;    Abefic Merhed Alyvag Pancam Abemos Melcor Ludoct Eupvac Echpas Passcr Poa2</span></span>
<span><span class="co">#&gt; M1      0      0      0  0.258      0  0.258      0  0.258      0  0.258    0</span></span>
<span><span class="co">#&gt; M2      0      0      0  0.000      0  0.183      0  0.000      0  0.000    0</span></span>
<span><span class="co">#&gt; M3      0      0      0  0.000      0  0.177      0  0.000      0  0.000    0</span></span>
<span><span class="co">#&gt;    Carhal Dendio Casobt Aesind Cyprot Ipocop Cynarc Walind Sessp. Phynod Echell</span></span>
<span><span class="co">#&gt; M1  0.000      0      0      0      0      0  0.775      0  0.258  0.258  0.000</span></span>
<span><span class="co">#&gt; M2  0.000      0      0      0      0      0  0.000      0  0.000  0.000  0.000</span></span>
<span><span class="co">#&gt; M3  0.177      0      0      0      0      0  0.000      0  0.000  0.884  0.177</span></span>
<span><span class="co">#&gt;    Helind Ipoaqu Orysp. Elesp. Psespi Ludads Polatt Poa1 Helcri Physp. Goopur</span></span>
<span><span class="co">#&gt; M1  0.000  0.000  0.000  0.000  0.000  0.000  0.000    0      0      0      0</span></span>
<span><span class="co">#&gt; M2  0.000  0.000  0.913  0.183  0.183  0.183  0.183    0      0      0      0</span></span>
<span><span class="co">#&gt; M3  0.177  0.177  0.000  0.177  0.177  0.000  0.000    0      0      0      0</span></span></code></pre></div>
<p>However, when using site-by-site dissimilarity matrices as input for
<code><a href="../reference/vegclust.html">vegclustdist()</a></code>, the indices of objects are returned
instead:</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetland.kmdd</span> <span class="op">=</span> <span class="fu"><a href="../reference/vegclust.html">vegclustdist</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">dchord</span>, mobileMemb<span class="op">=</span><span class="fl">3</span>, </span>
<span>                      method<span class="op">=</span><span class="st">"KMdd"</span>, nstart<span class="op">=</span><span class="fl">20</span><span class="op">)</span></span>
<span><span class="va">wetland.kmdd</span><span class="op">$</span><span class="va">mobileCenters</span></span>
<span><span class="co">#&gt; [1] 11 34 23</span></span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="supervised-classification-as-vegclust-and-vegclass">Supervised classification: <code>as.vegclust()</code> and
<code>vegclass()</code><a class="anchor" aria-label="anchor" href="#supervised-classification-as-vegclust-and-vegclass"></a>
</h3>
<p>Vegetation types are meant to be used. For example, a new area may be
surveyed and a map of vegetation types may be needed. Here we simulate
the process of assigning new observations to a vegetation classification
created <em>a priori</em>. In order to simulate this two-step process,
we split our example data set into two matrices, one with the 31 objects
whose group classification will be known <em>a priori</em> and the other
with the 10 objects whose classification is to be studied:</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetland.31</span> <span class="op">=</span> <span class="va">wetlandchord</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">31</span>,<span class="op">]</span></span>
<span><span class="va">wetland.31</span> <span class="op">=</span> <span class="va">wetland.31</span><span class="op">[</span>,<span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">colSums</a></span><span class="op">(</span><span class="va">wetland.31</span><span class="op">)</span><span class="op">&gt;</span><span class="fl">0</span><span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/dim.html" class="external-link">dim</a></span><span class="op">(</span><span class="va">wetland.31</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 31 27</span></span>
<span><span class="va">wetland.10</span> <span class="op">=</span> <span class="va">wetlandchord</span><span class="op">[</span><span class="op">-</span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">31</span><span class="op">)</span>,<span class="op">]</span></span>
<span><span class="va">wetland.10</span> <span class="op">=</span> <span class="va">wetland.10</span><span class="op">[</span>,<span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">colSums</a></span><span class="op">(</span><span class="va">wetland.10</span><span class="op">)</span><span class="op">&gt;</span><span class="fl">0</span><span class="op">]</span> </span>
<span><span class="fu"><a href="https://rdrr.io/r/base/dim.html" class="external-link">dim</a></span><span class="op">(</span><span class="va">wetland.10</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 10 22</span></span></code></pre></div>
<p>As initial classification, we simply take the two groups resulting
from a K-means analysis (using function <code><a href="https://rdrr.io/r/stats/kmeans.html" class="external-link">kmeans()</a></code> from the
<code>stats</code> package) on the first data set:</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">km</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/kmeans.html" class="external-link">kmeans</a></span><span class="op">(</span><span class="va">wetland.31</span>, <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">groups</span> <span class="op">=</span> <span class="va">km</span><span class="op">$</span><span class="va">cluster</span></span>
<span><span class="va">groups</span></span>
<span><span class="co">#&gt;  5  8 13  4 17  3  9 21 16 14  2 15  1  7 10 40 23 25 22 20  6 18 12 39 19 11 </span></span>
<span><span class="co">#&gt;  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  1  1  1  1  1  1  1  1  1  1  1 </span></span>
<span><span class="co">#&gt; 30 34 28 31 26 </span></span>
<span><span class="co">#&gt;  1  1  1  1  1</span></span></code></pre></div>
<p>The idea is to know whether the ten objects of the second data set
may be assigned to the vegetation types defined using the first data
set. Because our initial classification was not obtained using function
<code><a href="../reference/vegclust.html">vegclust()</a></code>, we need to transform the input classification
of 31 objects into an object of class <code>vegclust</code>. This is
done using function <code><a href="../reference/as.vegclust.html">as.vegclust()</a></code>:</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetland.31.km</span> <span class="op">=</span> <span class="fu"><a href="../reference/as.vegclust.html">as.vegclust</a></span><span class="op">(</span><span class="va">wetland.31</span>, <span class="va">groups</span><span class="op">)</span></span></code></pre></div>
<p>Note that we did not specify the clustering model for our
<code>vegclust</code> object. By default, the clustering method is
K-means (KM):</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetland.31.km</span><span class="op">$</span><span class="va">method</span></span>
<span><span class="co">#&gt; [1] "KM"</span></span></code></pre></div>
<p>In this case, this matches the way we obtained our initial
classification. In general, however, we may have a classification
obtained following an informal (or unknown) procedure, and we will
choose the clustering model according to our preferences for
assignments. Once we have our object <code>vegclust</code> we can use
function <code><a href="../reference/vegclass.html">vegclass()</a></code> to <em>assign</em> the second set of
observations according to the membership rule of the k-means cluster
model:</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetland.10.km</span> <span class="op">=</span> <span class="fu"><a href="../reference/vegclass.html">vegclass</a></span><span class="op">(</span><span class="va">wetland.31.km</span>, <span class="va">wetland.10</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/defuzzify.html">defuzzify</a></span><span class="op">(</span><span class="va">wetland.10.km</span><span class="op">)</span><span class="op">$</span><span class="va">cluster</span></span>
<span><span class="co">#&gt;  29  33  24  36  37  41  27  32  35  38 </span></span>
<span><span class="co">#&gt; "1" "1" "1" "1" "1" "1" "1" "1" "2" "2"</span></span></code></pre></div>
<p>The same procedure can be repeated using dissimilarity matrices.
First, we call <code><a href="../reference/as.vegclust.html">as.vegclust()</a></code> to create a vegclust
object:</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetland.31.km.d</span> <span class="op">=</span> <span class="fu"><a href="../reference/as.vegclust.html">as.vegclust</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/dist.html" class="external-link">dist</a></span><span class="op">(</span><span class="va">wetland.31</span><span class="op">)</span>, <span class="va">groups</span><span class="op">)</span></span></code></pre></div>
<p>After that, we need a matrix of distances between the set of
observations to be assigned and the original set of 31 observations.
This can be obtained from the original distance matrix including all
pairs of observations:</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetland.d.10.31</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html" class="external-link">as.data.frame</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">as.matrix</a></span><span class="op">(</span><span class="va">dchord</span><span class="op">)</span><span class="op">[</span><span class="fl">32</span><span class="op">:</span><span class="fl">41</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">31</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<p>Once we have these two objects we can use function
<code><a href="../reference/vegclass.html">vegclass()</a></code> to <em>assign</em> the second set of
observations according to the membership rule of the k-means cluster
model:</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetland.d.11.km</span> <span class="op">=</span> <span class="fu"><a href="../reference/vegclass.html">vegclass</a></span><span class="op">(</span><span class="va">wetland.31.km.d</span>,<span class="va">wetland.d.10.31</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/defuzzify.html">defuzzify</a></span><span class="op">(</span><span class="va">wetland.d.11.km</span><span class="op">)</span><span class="op">$</span><span class="va">cluster</span></span>
<span><span class="co">#&gt;  29  33  24  36  37  41  27  32  35  38 </span></span>
<span><span class="co">#&gt; "1" "1" "1" "1" "1" "1" "1" "1" "2" "2"</span></span></code></pre></div>
<p>Note that in both cases all the objects of the second set were
assigned to the nearest cluster. What if we want to determine whether it
is more appropriate for any of the objects to define a new vegetation
type? In that is case, we may do better by using noise clustering. We
can choose, for example, the hard noise clustering (HNC) model:</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetland.31.nc</span> <span class="op">=</span> <span class="fu"><a href="../reference/as.vegclust.html">as.vegclust</a></span><span class="op">(</span><span class="va">wetland.31</span>, <span class="va">groups</span>, method<span class="op">=</span><span class="st">"HNC"</span>, </span>
<span>                            dnoise <span class="op">=</span> <span class="fl">0.8</span><span class="op">)</span></span>
<span><span class="va">wetland.10.nc</span> <span class="op">=</span> <span class="fu"><a href="../reference/vegclass.html">vegclass</a></span><span class="op">(</span><span class="va">wetland.31.nc</span>, <span class="va">wetland.10</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/defuzzify.html">defuzzify</a></span><span class="op">(</span><span class="va">wetland.10.nc</span><span class="op">)</span><span class="op">$</span><span class="va">cluster</span></span>
<span><span class="co">#&gt;  29  33  24  36  37  41  27  32  35  38 </span></span>
<span><span class="co">#&gt; "1" "1" "N" "1" "N" "N" "N" "N" "N" "2"</span></span></code></pre></div>
<p>An additional parameter is needed: the distance to the noise class
‘dnoise’,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math>.
This can be set either conventionally (depending on the level of
abstraction of vegetation types) or by relying on the variance of the
original clusters <span class="citation">(De Cáceres, Oliva, and Font
2006)</span>. The results of the noise clustering model show that
several of the ten objects are assigned to the noise class (‘N’), which
indicates that some of them could be used to define a new cluster.</p>
</div>
<div class="section level3">
<h3 id="extending-vegetation-classifications">Extending vegetation classifications<a class="anchor" aria-label="anchor" href="#extending-vegetation-classifications"></a>
</h3>
<p>Allowing vegetation classifications to be dynamic entities, in the
sense that they may be modified or extended as new surveys are conducted
(or in general, when new data becomes available) increases their
usability <span class="citation">(De Cáceres, Font, and Oliva 2010;
Wiser and De Cáceres 2012)</span>. The aim here is to preserve the two
prototypes of the initial classification and let <code>vegclust</code>
to define a new vegetation type.</p>
<div class="section level4">
<h4 id="conforming-vegetation-data-sets">Conforming vegetation data sets<a class="anchor" aria-label="anchor" href="#conforming-vegetation-data-sets"></a>
</h4>
<p>When new vegetation data becomes available, the set of species in the
new data set will not normally be the same as the set of species used in
the original classification exercise. In this situation, the
practitioner will needs to bring the two sets of samples to the same
resemblance space. In our example we divided our initial data set into
two subsets of 31 and 10 sites, respectively
(i.e. <code>wetland.31</code> and <code>wetland.10</code>). Thus, our
original data set had a common set of species. However, we will now
pretend that <code>wetland.31</code> and <code>wetland.10</code> were
obtained independently. A useful function to create a common space of
species for two sets of vegetation observations is
<code><a href="../reference/conformveg.html">conformveg()</a></code>:</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cf</span> <span class="op">=</span> <span class="fu"><a href="../reference/conformveg.html">conformveg</a></span><span class="op">(</span><span class="va">wetland.31</span>, <span class="va">wetland.10</span><span class="op">)</span></span>
<span><span class="va">wetland.31.cf</span><span class="op">&lt;-</span> <span class="va">cf</span><span class="op">$</span><span class="va">x</span></span>
<span><span class="va">wetland.10.cf</span><span class="op">&lt;-</span> <span class="va">cf</span><span class="op">$</span><span class="va">y</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/dim.html" class="external-link">dim</a></span><span class="op">(</span><span class="va">wetland.31.cf</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 31 33</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/dim.html" class="external-link">dim</a></span><span class="op">(</span><span class="va">wetland.10.cf</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 10 33</span></span></code></pre></div>
<p>The only difference between these new objects and the preceeding ones
is that they include extra columns with zeros, so that the set of
columns (i.e. species) match between the two data sets.</p>
</div>
<div class="section level4">
<h4 id="re-calculating-the-centroids-of-the-initial-classification">Re-calculating the centroids of the initial classification<a class="anchor" aria-label="anchor" href="#re-calculating-the-centroids-of-the-initial-classification"></a>
</h4>
<p>Another step we need to conduct before calling <code>vegclust</code>
is to re-calculate the centroids of the initial classification in the
resemblance space of all species. Thus, we need to call
<code><a href="../reference/clustcentroid.html">clustcentroid()</a></code> using the conformed data set as input:</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fixed</span> <span class="op">=</span> <span class="fu"><a href="../reference/clustcentroid.html">clustcentroid</a></span><span class="op">(</span><span class="va">wetland.31.cf</span>, <span class="va">groups</span><span class="op">)</span></span></code></pre></div>
<p>Again, these centroids are exactly like the original ones except that
they are expressed in a matrix that includes extra zeros for the new
species.</p>
</div>
<div class="section level4">
<h4 id="calling-vegclust-with-fixed-prototypes">Calling <code>vegclust</code> with fixed prototypes<a class="anchor" aria-label="anchor" href="#calling-vegclust-with-fixed-prototypes"></a>
</h4>
<p>At this point we are ready to call function <code><a href="../reference/vegclust.html">vegclust()</a></code>
with the new data set (again, its conformed version):</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetland.nc</span> <span class="op">=</span> <span class="fu"><a href="../reference/vegclust.html">vegclust</a></span><span class="op">(</span><span class="va">wetland.10.cf</span>, mobileCenters<span class="op">=</span><span class="fl">1</span>, </span>
<span>                      fixedCenters <span class="op">=</span> <span class="va">fixed</span>, </span>
<span>                      method <span class="op">=</span> <span class="va">wetland.31.nc</span><span class="op">$</span><span class="va">method</span>,</span>
<span>                      dnoise<span class="op">=</span><span class="va">wetland.31.nc</span><span class="op">$</span><span class="va">dnoise</span>, nstart<span class="op">=</span><span class="fl">10</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/defuzzify.html">defuzzify</a></span><span class="op">(</span><span class="va">wetland.nc</span><span class="op">)</span><span class="op">$</span><span class="va">cluster</span></span>
<span><span class="co">#&gt;   29   33   24   36   37   41   27   32   35   38 </span></span>
<span><span class="co">#&gt; "F2" "F2" "M1" "M1" "M1" "M1"  "N"  "N"  "N" "F3"</span></span></code></pre></div>
<p>Here, the function <code><a href="../reference/vegclust.html">vegclust()</a></code> has renamed the original
clusters as ‘F2’ and ‘F3’ (indicating that they are now fixed), while
the new cluster is named ‘M1’.</p>
<p>Instead of relying on the Noise clustering model, we could have
chosen to use the K-means model to extend the classification:</p>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetland.km</span> <span class="op">=</span> <span class="fu"><a href="../reference/vegclust.html">vegclust</a></span><span class="op">(</span><span class="va">wetland.10.cf</span>, mobileCenters<span class="op">=</span><span class="fl">1</span>, </span>
<span>                      fixedCenters <span class="op">=</span> <span class="va">fixed</span>, </span>
<span>                      method <span class="op">=</span> <span class="st">"KM"</span>,</span>
<span>                      nstart<span class="op">=</span><span class="fl">10</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/defuzzify.html">defuzzify</a></span><span class="op">(</span><span class="va">wetland.km</span><span class="op">)</span><span class="op">$</span><span class="va">cluster</span></span>
<span><span class="co">#&gt;   29   33   24   36   37   41   27   32   35   38 </span></span>
<span><span class="co">#&gt; "F2" "F2" "M1" "M1" "M1" "M1" "M1" "M1" "F3" "F3"</span></span></code></pre></div>
<p>This avoids having objects in the Noise class. However, note that the
noise clustering model allows objects in the Noise to be classified
later on when new data becomes available, instead of forcing them to
belong to one cluster or the other (i.e. the partition restriction).</p>
</div>
<div class="section level4">
<h4 id="extending-or-refining-classifications">Extending or refining classifications?<a class="anchor" aria-label="anchor" href="#extending-or-refining-classifications"></a>
</h4>
<p>Instead of calling <code><a href="../reference/vegclust.html">vegclust()</a></code> with the new data set
only, we could have chosen to use the set of all vegetation
observations:</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetland.nc</span> <span class="op">=</span> <span class="fu"><a href="../reference/vegclust.html">vegclust</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="va">wetland.31.cf</span>,<span class="va">wetland.10.cf</span><span class="op">)</span>, mobileCenters<span class="op">=</span><span class="fl">1</span>, </span>
<span>                      fixedCenters <span class="op">=</span> <span class="va">fixed</span>, </span>
<span>                      method <span class="op">=</span> <span class="va">wetland.31.nc</span><span class="op">$</span><span class="va">method</span>,</span>
<span>                      dnoise<span class="op">=</span><span class="va">wetland.31.nc</span><span class="op">$</span><span class="va">dnoise</span>, nstart<span class="op">=</span><span class="fl">10</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/defuzzify.html">defuzzify</a></span><span class="op">(</span><span class="va">wetland.nc</span><span class="op">)</span><span class="op">$</span><span class="va">cluster</span></span>
<span><span class="co">#&gt;    5    8   13    4   17    3    9   21   16   14    2   15    1    7   10   40 </span></span>
<span><span class="co">#&gt; "F3" "F3" "F3" "F3" "F3" "F3"  "N" "F3" "F3" "F3" "F3" "F3" "F3" "F3"  "N" "F2" </span></span>
<span><span class="co">#&gt;   23   25   22   20    6   18   12   39   19   11   30   34   28   31   26   29 </span></span>
<span><span class="co">#&gt; "F2" "F2" "M1" "F2" "F2" "F2" "F2" "F2" "F2" "F2"  "N"  "N"  "N"  "N" "F2" "F2" </span></span>
<span><span class="co">#&gt;   33   24   36   37   41   27   32   35   38 </span></span>
<span><span class="co">#&gt; "F2"  "N" "F2"  "N"  "N"  "N"  "N" "M1" "M1"</span></span></code></pre></div>
<p>Note that some of the objects in the first data set may have been
reassigned (to a different cluster or to the Noise class). While the
centroids of the original classification are preserved, the membership
of particular objects may change because the classification now includes
new prototypes to which objects may be assigned. Using the complete data
set instead of the new data implies that the used is ready to accept
these reassignments. If the new memberships were strikingly different
from the original ones, one might decide to start the three group
classification from scratch.</p>
</div>
<div class="section level4">
<h4 id="using-vegclustdist-with-fixed-prototypes">Using <code>vegclustdist()</code> with fixed prototypes<a class="anchor" aria-label="anchor" href="#using-vegclustdist-with-fixed-prototypes"></a>
</h4>
<p>Extending vegetation classifications can also be done in the
distance-based mode. In this case we do not have explicit coordinates
for fixed prototypes, but we may have the distances to these centers. To
begin our example we use the distances to the two clusters that we
obtained at the stage of assigning new observations:</p>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fixedDist</span> <span class="op">=</span> <span class="va">wetland.d.11.km</span><span class="op">$</span><span class="va">dist2clusters</span></span></code></pre></div>
<p>With this information, we can now call <code><a href="../reference/vegclust.html">vegclustdist()</a></code> to
define a new cluster while accounting for the previous ones:</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetland.km.d</span> <span class="op">=</span> <span class="fu"><a href="../reference/vegclust.html">vegclustdist</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/dist.html" class="external-link">dist</a></span><span class="op">(</span><span class="va">wetland.10</span><span class="op">)</span>, mobileMemb <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                            fixedDistToCenters<span class="op">=</span><span class="va">fixedDist</span>, </span>
<span>                            method <span class="op">=</span> <span class="st">"KM"</span>,</span>
<span>                            nstart<span class="op">=</span><span class="fl">10</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/defuzzify.html">defuzzify</a></span><span class="op">(</span><span class="va">wetland.km.d</span><span class="op">)</span><span class="op">$</span><span class="va">cluster</span></span>
<span><span class="co">#&gt;   29   33   24   36   37   41   27   32   35   38 </span></span>
<span><span class="co">#&gt; "F2" "F2" "M1" "M1" "M1" "M1" "M1" "M1" "F3" "F3"</span></span></code></pre></div>
<p>Analogously to <code>vegclust</code>, we could have chosen to use the
set of all vegetation observations. In this case, we need to pool the
distances to the centers:</p>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fixedDist</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="va">wetland.31.km.d</span><span class="op">$</span><span class="va">dist2clusters</span>, <span class="va">wetland.d.11.km</span><span class="op">$</span><span class="va">dist2clusters</span><span class="op">)</span></span></code></pre></div>
<p>And then we call <code><a href="../reference/vegclust.html">vegclustdist()</a></code> using the full distance
matrix:</p>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">wetland.km.d</span> <span class="op">=</span> <span class="fu"><a href="../reference/vegclust.html">vegclustdist</a></span><span class="op">(</span><span class="va">dchord</span>, mobileMemb <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                            fixedDistToCenters<span class="op">=</span><span class="va">fixedDist</span>, </span>
<span>                            method <span class="op">=</span> <span class="st">"KM"</span>,</span>
<span>                            nstart<span class="op">=</span><span class="fl">10</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/defuzzify.html">defuzzify</a></span><span class="op">(</span><span class="va">wetland.km.d</span><span class="op">)</span><span class="op">$</span><span class="va">cluster</span></span>
<span><span class="co">#&gt;    5    8   13    4   17    3    9   21   16   14    2   15    1    7   10   40 </span></span>
<span><span class="co">#&gt; "F3" "F3" "F3" "F3" "F3" "F3" "F3" "F3" "F3" "F3" "F3" "F3" "F3" "F3" "F3" "F2" </span></span>
<span><span class="co">#&gt;   23   25   22   20    6   18   12   39   19   11   30   34   28   31   26   29 </span></span>
<span><span class="co">#&gt; "F2" "F2" "F2" "F2" "F2" "F2" "F2" "F2" "F2" "F2" "M1" "M1" "M1" "M1" "F2" "F2" </span></span>
<span><span class="co">#&gt;   33   24   36   37   41   27   32   35   38 </span></span>
<span><span class="co">#&gt; "F2" "M1" "M1" "M1" "M1" "M1" "M1" "F3" "F3"</span></span></code></pre></div>
<p>As before, some objects may be reclassified in different clusters
when using this option.</p>
</div>
</div>
</div>
<div class="section level2">
<h2 id="cluster-characterization">Cluster characterization<a class="anchor" aria-label="anchor" href="#cluster-characterization"></a>
</h2>
<p>In this section we show how to use auxiliary functions that allow
cluster properties to be extracted from an input classification. In all
examples we will use this <em>a priori</em> classification of our data
set:</p>
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">groups</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">17</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">14</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">3</span>,<span class="fl">10</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="cluster-prototypes-clustcentroid-and-clustmedoid">Cluster prototypes: <code>clustcentroid()</code> and
<code>clustmedoid()</code><a class="anchor" aria-label="anchor" href="#cluster-prototypes-clustcentroid-and-clustmedoid"></a>
</h3>
<p>Functions <code><a href="../reference/clustcentroid.html">clustcentroid()</a></code> and <code><a href="../reference/clustcentroid.html">clustmedoid()</a></code>
allow the cluster prototypes to be calculated according to an input
classification structure, which can be specified using either a cluster
vector or a membership matrix.</p>
<p>For example, with <code><a href="../reference/clustcentroid.html">clustcentroid()</a></code> we can calculate the
coordinates of the centroids of the initial groups using:</p>
<div class="sourceCode" id="cb45"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">centroids</span> <span class="op">=</span> <span class="fu"><a href="../reference/clustcentroid.html">clustcentroid</a></span><span class="op">(</span><span class="va">wetlandchord</span>, <span class="va">groups</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="va">centroids</span>, dig<span class="op">=</span><span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#&gt;   Abefic Merhed Alyvag Pancam Abemos Melcor Ludoct Eupvac Echpas Passcr Poa2</span></span>
<span><span class="co">#&gt; 1  0.000  0.000  0.009  0.009  0.000  0.054  0.000  0.020  0.031  0.000 0.00</span></span>
<span><span class="co">#&gt; 2  0.013  0.015  0.036  0.088  0.000  0.178  0.000  0.090  0.116  0.000 0.01</span></span>
<span><span class="co">#&gt; 3  0.000  0.047  0.000  0.371  0.036  0.253  0.019  0.182  0.061  0.026 0.00</span></span>
<span><span class="co">#&gt;   Carhal Dendio Casobt Aesind Cyprot Ipocop Cynarc Walind Sessp. Phynod Echell</span></span>
<span><span class="co">#&gt; 1  0.064  0.000  0.016  0.009  0.000  0.000  0.000  0.068  0.144  0.090  0.022</span></span>
<span><span class="co">#&gt; 2  0.036  0.000  0.000  0.064  0.179  0.028  0.106  0.055  0.117  0.506  0.119</span></span>
<span><span class="co">#&gt; 3  0.000  0.027  0.000  0.019  0.039  0.018  0.301  0.090  0.138  0.204  0.158</span></span>
<span><span class="co">#&gt;   Helind Ipoaqu Orysp. Elesp. Psespi Ludads Polatt  Poa1 Helcri Physp. Goopur</span></span>
<span><span class="co">#&gt; 1  0.112  0.055  0.609  0.164  0.192  0.204  0.097 0.000  0.000   0.00   0.00</span></span>
<span><span class="co">#&gt; 2  0.138  0.048  0.126  0.125  0.027  0.000  0.000 0.013  0.013   0.00   0.00</span></span>
<span><span class="co">#&gt; 3  0.090  0.037  0.172  0.000  0.000  0.000  0.000 0.000  0.000   0.02   0.02</span></span></code></pre></div>
<p>As medoids are prototypes that are chosen among the objects to be
classified, function <code><a href="../reference/clustcentroid.html">clustmedoid()</a></code> does not return
coordinates but the indices of objects. The following code uses the
medoid hard cluster equation to determine the medoids of each
cluster:</p>
<div class="sourceCode" id="cb46"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">medoids</span> <span class="op">=</span> <span class="fu"><a href="../reference/clustcentroid.html">clustmedoid</a></span><span class="op">(</span><span class="va">wetlandchord</span>, <span class="va">groups</span><span class="op">)</span></span>
<span><span class="va">medoids</span></span>
<span><span class="co">#&gt;  2 12 41 </span></span>
<span><span class="co">#&gt; 11 23 37</span></span></code></pre></div>
<p>The value returned by function <code>medoid()</code> is a vector of
indices with the corresponding object names (which are numbers in this
particular case). If the classification structure is a fuzzy membership
matrix, the cluster centroids or medoids are determined using the fuzzy
centroid or fuzzy medoid equation, respectively.</p>
</div>
<div class="section level3">
<h3 id="cluster-internal-variability-clustvar">Cluster internal variability: <code>clustvar()</code><a class="anchor" aria-label="anchor" href="#cluster-internal-variability-clustvar"></a>
</h3>
<p>Vegetation types may differ in their internal variability. The
function <code><a href="../reference/clustvar.html">clustvar()</a></code> allows the amount of compositional
variation (i.e. beta diversity) observed among the sites of sites
belonging to each cluster to be determined. For clusters whose prototype
is a centroid, this is calculated as the mean of squared distances from
each object of the group to the group centroid. For example, the
variability for a given group
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
would be:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>k</mi></msub></munderover><msubsup><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow><mn>2</mn></msubsup><mi>/</mi><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\begin{equation}
Var(i) = \sum_{j=1}^{n_k}{e_{ij}^2}/n_i
\end{equation}</annotation></semantics></math> Note that division is by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>i</mi></msub><annotation encoding="application/x-tex">n_i</annotation></semantics></math>
and not by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>n</mi><mi>i</mi></msub><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(n_i-1)</annotation></semantics></math>,
which would give an unbiased sample estimate. Thus, the variances
calculated in <code><a href="../reference/clustvar.html">clustvar()</a></code> are population variances. For
example, the variances of the three groups in our examples are:</p>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/clustvar.html">clustvar</a></span><span class="op">(</span><span class="va">wetlandchord</span>, <span class="va">groups</span><span class="op">)</span></span>
<span><span class="co">#&gt;         1         2         3 </span></span>
<span><span class="co">#&gt; 0.4554668 0.5466579 0.5293836</span></span></code></pre></div>
<p>The reason why population values are produced, instead of sample
estimates, is because it allows the variance to be calculated using
fuzzy membership values:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msubsup><mi>u</mi><mrow><mi>i</mi><mi>j</mi></mrow><mi>m</mi></msubsup><msubsup><mi>e</mi><mrow><mi>i</mi><mi>j</mi></mrow><mn>2</mn></msubsup></mrow><mrow><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msubsup><mi>u</mi><mrow><mi>i</mi><mi>j</mi></mrow><mi>m</mi></msubsup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\begin{equation}
Var(i) = \frac{\sum_{j=1}^{n}u_{ij}^me_{ij}^2}{\sum_{j=1}^n{u_{ij}^m}}
\end{equation}</annotation></semantics></math></p>
<p>Cluster variances can also be obtained using distance or
dissimilarity matrices. In this case, the variance for a given group is
calculated as:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mn>1</mn><msubsup><mi>n</mi><mi>i</mi><mn>2</mn></msubsup></mfrac><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>i</mi></msub></munderover><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>i</mi></msub></munderover><msubsup><mi>d</mi><mrow><mi>k</mi><mi>l</mi></mrow><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\begin{equation}
Var(i) = \frac{1}{n_i^2} \sum_{k=1}^{n_i}\sum_{l=1}^{n_i}{d_{kl}^2}
\end{equation}</annotation></semantics></math> Again, division by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>n</mi><mi>i</mi></msub><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">n_i(n_i-1)</annotation></semantics></math>
instead of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>n</mi><mi>i</mi><mn>2</mn></msubsup><annotation encoding="application/x-tex">n_i^2</annotation></semantics></math>
would give an unbiased variance estimate. Because in our example the
community data had been transformed using the chord transformation, the
same variance values can be obtained using a distance matrix with chord
distances:</p>
<div class="sourceCode" id="cb48"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/clustvar.html">clustvar</a></span><span class="op">(</span><span class="va">dchord</span>, <span class="va">groups</span><span class="op">)</span></span>
<span><span class="co">#&gt;         1         2         3 </span></span>
<span><span class="co">#&gt; 0.4554668 0.5466579 0.5293836</span></span></code></pre></div>
<p>Finally, if no classification structure is provided function
<code><a href="../reference/clustvar.html">clustvar()</a></code> will return the overall variance (beta
diversity) of the data table:</p>
<div class="sourceCode" id="cb49"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/clustvar.html">clustvar</a></span><span class="op">(</span><span class="va">wetlandchord</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.6751038</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="distance-between-clusters-interclustdist">Distance between clusters: <code>interclustdist()</code><a class="anchor" aria-label="anchor" href="#distance-between-clusters-interclustdist"></a>
</h3>
<p>Calculating distance between pairs of cluster prototypes is useful to
determine which vegetation types are more similar and which are more
distinct. When prototypes of vegetation types are chosen to be cluster
medoids, then the resemblance between vegetation types can be defined as
the resemblance between the corresponding medoids:</p>
<div class="sourceCode" id="cb50"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/dist.html" class="external-link">as.dist</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">as.matrix</a></span><span class="op">(</span><span class="va">dchord</span><span class="op">)</span><span class="op">[</span><span class="va">medoids</span>,<span class="va">medoids</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">#&gt;           2       12</span></span>
<span><span class="co">#&gt; 12 1.344006         </span></span>
<span><span class="co">#&gt; 41 1.093926 1.363297</span></span></code></pre></div>
<p>In contrast, if prototypes of vegetation types are chosen to be
cluster centroids, the distance between two vegetation types should be
defined as the distance between the cluster centroids. Following our
example, we can simply use function <code><a href="https://rdrr.io/r/stats/dist.html" class="external-link">dist()</a></code> on the matrix of
centroid coordinates:</p>
<div class="sourceCode" id="cb51"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/dist.html" class="external-link">dist</a></span><span class="op">(</span><span class="va">centroids</span><span class="op">)</span></span>
<span><span class="co">#&gt;           1         2</span></span>
<span><span class="co">#&gt; 2 0.7624211          </span></span>
<span><span class="co">#&gt; 3 0.8004329 0.5298008</span></span></code></pre></div>
<p>Alternatively, the function <code><a href="../reference/interclustdist.html">interclustdist()</a></code> allows the
distance between pairs of centroids to be calculated without the
coordinates of centroids being supplied. Instead, the matrix of
distances between objects is used. For example, if the distance between
the centroids of groups
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
is desired, we can calculate the squared distance by:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>d</mi><mn>2</mn></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><msubsup><mi>u</mi><mrow><mi>i</mi><mi>k</mi></mrow><mi>m</mi></msubsup><msubsup><mi>u</mi><mrow><mi>j</mi><mi>l</mi></mrow><mi>m</mi></msubsup><msup><msub><mi>d</mi><mrow><mi>k</mi><mi>l</mi></mrow></msub><mn>2</mn></msup></mrow></mrow><mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msubsup><mi>u</mi><mrow><mi>i</mi><mi>k</mi></mrow><mi>m</mi></msubsup><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msubsup><mi>u</mi><mrow><mi>j</mi><mi>l</mi></mrow><mi>m</mi></msubsup></mrow></mfrac><mo>−</mo><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{equation}
d^2(i,j)=\frac{\sum_{k=1}^{n}\sum_{l=1}^{n}{u_{ik}^mu_{jl}^m{d_{kl}}^2}}{\sum_{k=1}^n{u_{ik}^m}\sum_{l=1}^n{u_{jl}^m}} - Var(i) - Var(j)
\end{equation}</annotation></semantics></math> Using the former equation
in our example would result in:</p>
<div class="sourceCode" id="cb52"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/interclustdist.html">interclustdist</a></span><span class="op">(</span><span class="va">dchord</span>,<span class="va">groups</span><span class="op">)</span></span>
<span><span class="co">#&gt;           1         2</span></span>
<span><span class="co">#&gt; 2 0.7624211          </span></span>
<span><span class="co">#&gt; 3 0.8004329 0.5298008</span></span></code></pre></div>
<p>which returns the same values as before.</p>
</div>
<div class="section level3">
<h3 id="constancy-classes-clustconst">Constancy classes: <code>clustconst()</code><a class="anchor" aria-label="anchor" href="#constancy-classes-clustconst"></a>
</h3>
<p>One way of characterizing a vegetation type is to examine how
frequently each species occurs in vegetation observations belonging to
the type. This frequency is often called <em>constancy</em> and the
table that contains the constancy of all species in all vegetation types
is called <em>constancy table</em>. The function
<code><a href="../reference/clustconst.html">clustconst()</a></code> allows this table to be calculated:</p>
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">c</span> <span class="op">=</span> <span class="fu"><a href="../reference/clustconst.html">clustconst</a></span><span class="op">(</span><span class="va">wetlandchord</span>, memb <span class="op">=</span> <span class="fu"><a href="../reference/as.memb.html">as.memb</a></span><span class="op">(</span><span class="va">groups</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>The R object returned by <code><a href="../reference/clustconst.html">clustconst()</a></code> can be examined in
several ways. First, it is useful to print the constancy table ordering
species from high to low constancy for each cluster:</p>
<div class="sourceCode" id="cb54"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">d</span><span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">c</span>, mode<span class="op">=</span><span class="st">"all"</span><span class="op">)</span></span>
<span><span class="co">#&gt; ------------ 3 -------------</span></span>
<span><span class="co">#&gt;            3     2     1</span></span>
<span><span class="co">#&gt; Pancam 1.000 0.357 0.059</span></span>
<span><span class="co">#&gt; Melcor 1.000 0.786 0.294</span></span>
<span><span class="co">#&gt; Eupvac 0.800 0.357 0.118</span></span>
<span><span class="co">#&gt; Sessp. 0.600 0.500 0.412</span></span>
<span><span class="co">#&gt; Echell 0.600 0.357 0.118</span></span>
<span><span class="co">#&gt; ------------ 2 -------------</span></span>
<span><span class="co">#&gt;            3     2     1</span></span>
<span><span class="co">#&gt; Phynod 0.400 0.714 0.118</span></span>
<span><span class="co">#&gt; Helind 0.300 0.643 0.471</span></span>
<span><span class="co">#&gt; Elesp. 0.000 0.571 0.529</span></span>
<span><span class="co">#&gt; ------------ 1 -------------</span></span>
<span><span class="co">#&gt;            3     2     1</span></span>
<span><span class="co">#&gt; Orysp. 0.300 0.286 1.000</span></span>
<span><span class="co">#&gt; Ludads 0.000 0.000 0.824</span></span></code></pre></div>
<p>Alternatively, we can examine the constancy vector of each vegetation
type:</p>
<div class="sourceCode" id="cb55"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">c</span>, mode<span class="op">=</span><span class="st">"cluster"</span>, name<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">c</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co">#&gt; Orysp. 1.000 </span></span>
<span><span class="co">#&gt; Ludads 0.824 </span></span>
<span><span class="co">#&gt; Elesp. 0.529</span></span></code></pre></div>
</div>
</div>
<div class="section level2 unnumbered">
<h2 class="unnumbered" id="bibliography">Bibliography<a class="anchor" aria-label="anchor" href="#bibliography"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-Bezdek1981" class="csl-entry">
Bezdek, James C. 1981. <em><span class="nocase">Pattern recognition with
fuzzy objective functions</span></em>. New York: Plenum Press.
</div>
<div id="ref-Bowman1986" class="csl-entry">
Bowman, D. M. J. S., and B A Wilson. 1986. <span>“<span class="nocase">Wetland vegetation pattern on the Adelaide River flood
plain, Northern Territory, Australia.</span>”</span> <em>Proceedings of
the Royal Society of Queensland</em> 97: 69–77.
</div>
<div id="ref-Dale1995" class="csl-entry">
Dale, MB. 1995. <span>“<span class="nocase">Evaluating classification
strategies</span>.”</span> <em>Journal of Vegetation Science</em> 6 (3):
437–40.
</div>
<div id="ref-Dave1991" class="csl-entry">
Dave, R N. 1991. <span>“<span class="nocase">Characterization and
detection of noise in clustering</span>.”</span> <em>Pattern Recognition
Letters</em> 12 (11): 657–64.
</div>
<div id="ref-Dave1997" class="csl-entry">
Dave, R. N., and R. Krishnapuram. 1997. <span>“<span class="nocase">Robust clustering methods: a unified view</span>.”</span>
<em>IEEE Transactions on Fuzzy Systems</em> 5 (2): 270–93. <a href="https://doi.org/10.1109/91.580801" class="external-link">https://doi.org/10.1109/91.580801</a>.
</div>
<div id="ref-DeCaceres2010a" class="csl-entry">
De Cáceres, Miquel, Xavier Font, and Francesc Oliva. 2010. <span>“<span class="nocase">The management of vegetation classifications with fuzzy
clustering</span>.”</span> <em>Journal of Vegetation Science</em> 21
(6): 1138–51. <a href="https://doi.org/10.1111/j.1654-1103.2010.01211.x" class="external-link">https://doi.org/10.1111/j.1654-1103.2010.01211.x</a>.
</div>
<div id="ref-DeCaceres2006" class="csl-entry">
De Cáceres, Miquel, Francesc Oliva, and Xavier Font. 2006. <span>“<span class="nocase">On relational possibilistic clustering</span>.”</span>
<em>Pattern Recognition</em> 39 (11): 2010–24. <a href="https://doi.org/10.1016/j.patcog.2006.04.008" class="external-link">https://doi.org/10.1016/j.patcog.2006.04.008</a>.
</div>
<div id="ref-Hathaway1994" class="csl-entry">
Hathaway, R J, and James C Bezdek. 1994. <span>“<span class="nocase">NERF c-means: Non-euclidean relational fuzzy
clustering</span>.”</span> <em>Pattern Recognition</em> 27 (3): 429–37.
</div>
<div id="ref-Hathaway1989" class="csl-entry">
Hathaway, R J, J W Davenport, and James C Bezdek. 1989. <span>“<span class="nocase">Relational duals of the c-means clustering
algorithms</span>.”</span> <em>Pattern Recognition</em> 22 (2): 205–12.
</div>
<div id="ref-Hathaway1996" class="csl-entry">
Hathaway, R, J. C. Bezdek, and J Davenport. 1996. <span>“<span class="nocase">On relational data versions of c-means
algorithms</span>.”</span> <em>Pattern Recognition Letters</em> 17 (6):
607–12. <a href="https://doi.org/10.1016/0167-8655(96)00025-6" class="external-link">https://doi.org/10.1016/0167-8655(96)00025-6</a>.
</div>
<div id="ref-Krishnapuram1999" class="csl-entry">
Krishnapuram, Raghu, Anupam Joshi, and Liyu Yi. 1999. <span>“<span class="nocase">A Fuzzy relative of the k-medoids algorithm with
application to web document and snippet clustering</span>.”</span> In
<em>IEEE International Fuzzy Systems</em>, 1281–86.
</div>
<div id="ref-Krishnapuram1993" class="csl-entry">
Krishnapuram, R., and J. M. Keller. 1993. <span>“<span class="nocase">A
possibilistic approach to clustering</span>.”</span> <em>IEEE
Transactions on Fuzzy Systems</em> 1 (2): 98–110. <a href="https://doi.org/10.1109/91.227387" class="external-link">https://doi.org/10.1109/91.227387</a>.
</div>
<div id="ref-Krishnapuram1996" class="csl-entry">
———. 1996. <span>“<span class="nocase">The possibilistic C-means
algorithm: insights and recommendations</span>.”</span> <em>IEEE
Transactions on Fuzzy Systems</em> 4 (3): 385–93. <a href="https://doi.org/10.1109/91.531779" class="external-link">https://doi.org/10.1109/91.531779</a>.
</div>
<div id="ref-Legendre2001" class="csl-entry">
Legendre, Pierre, and Eugene Gallagher. 2001. <span>“<span class="nocase">Ecologically meaningful transformations for ordination of
species data</span>.”</span> <em>Oecologia</em> 129 (2): 271–80. <a href="https://doi.org/10.1007/s004420100716" class="external-link">https://doi.org/10.1007/s004420100716</a>.
</div>
<div id="ref-MacQueen1967" class="csl-entry">
MacQueen, J. 1967. <span>“<span class="nocase">Some methods for
classification and analysis of multivariate observation</span>.”</span>
In, edited by L M LeCam and J Neyman, 281–97. 0. Berkeley: University of
California Press.
</div>
<div id="ref-Moravec1989" class="csl-entry">
Moravec, J. 1989. <span>“<span class="nocase">Influences of the
individualistic concept of vegetation on syntaxonomy</span>.”</span>
<em>Vegetatio</em> 81 (1-2): 29–39. <a href="https://doi.org/10.1007/BF00045511" class="external-link">https://doi.org/10.1007/BF00045511</a>.
</div>
<div id="ref-Orloci1967" class="csl-entry">
Orlóci, L. 1967. <span>“<span class="nocase">An agglomerative method for
classification of plant comunities</span>.”</span> <em>Journal of
Ecology</em> 55 (0): 193–206.
</div>
<div id="ref-Wiser2012" class="csl-entry">
Wiser, Susan K., and Miquel De Cáceres. 2012. <span>“<span class="nocase">Updating vegetation classifications: an example with New
Zealand’s woody vegetation</span>.”</span> Edited by Sandor Bartha.
<em>Journal of Vegetation Science</em>, July, n/a–. <a href="https://doi.org/10.1111/j.1654-1103.2012.01450.x" class="external-link">https://doi.org/10.1111/j.1654-1103.2012.01450.x</a>.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Miquel De Cáceres.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.2.</p>
</div>

    </footer>
</div>





  </body>
</html>
